--
-- pGUI-IDE.exw (Phix/pGUI Layout Designer/IDE)
-- ============
--  plc - Phix Layout Constructor (pronounced pluck)
--  pluck - Phix Layout Constructor Kickstarter (pronounced pluck)
--  pdle - no!
--  IupLade.exw -  ugh
--  IupLaDe.exw -  ugh
--  ILD.exw -  ugh
--  IuPlade.exw -  ugh
--  pGlade.exw -  erm
--  pGalde.exw -  erm
--  pGuilade.exw -  erm
--  pGuialde.exw -  erm
--  pGuild.exw -    erm
--  guild.exw - erm/nah
--  pGUId.exw - erm
--  pide.exw -  erm
--  pIDE.exw -  erm - maybe...
--  pGLIDE.exw -    erm - maybe...
--  pGlide.exw -    nah
--  pGLADE.exw -    erm - maybe...
--  pGlade.exw -    nah
--  pGUIDE.exw -    erm - maybe  (pronounced with a silent p?)  <== best so far...
--    (pronounced puh-guide, similar to pagoda, but definately not pee-guide, the rival to the she-wee)
--  pguide.exw -    erm - maybe
--  GUIDE.exw -     erm - maybe
--  guide.exw -     erm - maybe
--  Guide.exw -     erm - maybe
--  GUIde.exw -     nah
--  pGUIde.exw -    nah
--  pGUI-IDE.exw -  actually, that probably wins (pronounced "pea-gooey-eyed", or sometimes just "Guide")

--DEV focus actually works fine w/o a console, or with this to start with...
?""

--TODO:
--  delete [DONE]
--  SUG: Try insert as 3 radios. Maybe also a drop-down for the insert?
--  SUG master list of all attributes, whether inherited/read-only/write-only/creation-only/not-suitable-here etc
--  write *2
--  test
--  help
--  Edix/ipc
--  create some dummy IupImage()s, the right size if possible (also IupImageRGBA) (for a start, sequence images)
--/*
(judicious replacement with IupSetAttributeHandle may be required)
[?DOC note that pGUI-IDE supports IupImages assigned via IupSetAttributeHandle only, not via IupSetHandle?]
Searching for: iupimage
 Files scanned 90, Directories scanned 11, Lines 203995
C:\Program Files (x86)\Phix\demo\pGUI\image.exw:68     Ihandle img_x = IupImage(11, 11, pixmap_x)
C:\Program Files (x86)\Phix\demo\pGUI\image.exw:74     Ihandle img_cursor = IupImage(32, 32, pixmap_cursor)
C:\Program Files (x86)\Phix\demo\pGUI\image.exw:125     IupSetAttributes(dlg, `TITLE="IupImage Example", SIZE=HALFxQUARTER, CURSOR=img_cursor`)
C:\Program Files (x86)\Phix\demo\pGUI\imgdisp.exw:69 hImg2 = IupImage(32, 32, image_bits1)
C:\Program Files (x86)\Phix\demo\pGUI\iup3Dctrls.exw:91 Ihandle image = IupImageRGBA(32, 32, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\iup3Dctrls.exw:117 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\iup3Dctrls.exw:142     image = IupImageRGBA(16, 16, image_data_32)
C:\Program Files (x86)\Phix\demo\pGUI\iup3Dctrls.exw:553     image_open = IupImage(16, 16, img_open)
C:\Program Files (x86)\Phix\demo\pGUI\iup3Dctrls.exw:554     image_close = IupImage(16, 16, img_close)
C:\Program Files (x86)\Phix\demo\pGUI\iup3Dctrls.exw:555     image_high = IupImage(16, 16, img_close)
C:\Program Files (x86)\Phix\demo\pGUI\list2.exw:52         image = IupImageRGBA(32, 32, imgdata);
C:\Program Files (x86)\Phix\demo\pGUI\list2.exw:80         image = IupImageRGBA(16, 16, imgdata);
C:\Program Files (x86)\Phix\demo\pGUI\list2.exw:108 Ihandle image = IupImage(16, 16, imgdata);
C:\Program Files (x86)\Phix\demo\pGUI\sample.exw:44 Ihandle image = IupImageRGBA(32, 32, imgdata);
C:\Program Files (x86)\Phix\demo\pGUI\sample.exw:67 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\sample.exw:383 --  img = IupImage(32,32, img_bits1);
C:\Program Files (x86)\Phix\demo\pGUI\sample.exw:392     img = IupImage(32,32, img_bits2);
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:63 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:87 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:111 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:135 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:159 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:183 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:207 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:231 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:255 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:279 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:303 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\toggle.exw:56     img1 = IupImage(16,16, img_1)
C:\Program Files (x86)\Phix\demo\pGUI\toggle.exw:57     img2 = IupImage(16,16, img_2)
C:\Program Files (x86)\Phix\demo\pGUI\tree.exw:44 Ihandle image = IupImageRGBA(16, 16, imgdata)
C:\Program Files (x86)\Phix\demo\pGUI\tree.exw:71   Ihandle image = IupImage(TEST_IMAGE_SIZE, TEST_IMAGE_SIZE, image_data_8)
--*/

constant SPACE = 0  -- disabled for this release (full investigation/analysis rqd)

--TODO (10/11/17):
-- remove menus from hierarchytree [DONE]
-- finish set_add_modes[2] testing [DONE, now to start using it... DONE]
-- remove menus from right-click menu [DONE]
-- when >1 window exists, initial focus should be on the drop-down. [DONE]
-- add a resize thing between ht & props [DONE]
-- add a TITLE and input field on the create window when appropriate. [DONE]
-- double-click on properties/new button pop-up [new_attr_cb & dblclick_cb => edit_attrib] [DONE]
-- actually delete (delete_cb) [DONE]
-- when integrated with edix, edit definition (button/tools menu on the properties window?)
-- another tool: the full list of attributes, as per IupLayoutDialog() (selectable)
-- SUG: File/Open?? (or from Edix-only?)
-- start the manual(s)
-- [OT] get pGUI-IDE to launch from Edix, and the (F1) help keys working
-- Qu: should Esc on liveview close the thing? - yes, for now...

--SUG use the USERDATAid attribute / IupTreeSetUserId / IupTreeGetUserId / IupTreeGetId
--SUG use IupTreeAddNodes instead:
--constant USEADDNODES = 01
--DEV DRAGDROPTREE / DROPFILESTARGET / DROPEQUALDRAG / SHOWDRAGDROP / DRAGDROP_CB / DROPFILES_CB at the
--   very least (if used) need rethinking.
--One small glitch...
--dragging onto a container:
--if the branch is expanded the dragged item is added as the first child
--if the branch is collapsed the dragged item is added as the next sibling
--AH: if it is say an IupFrame, you cannot add a child to expand/add - it just don't work.... you need to ask.
--Update: dropping into an empty branch seems more sensible...
--  Actually, drag and drop works just fine for all non-container target nodes, however when the target
--  is a container then a child/sibling question needs asking. Technically we don't need them all, but
--  we may as well have them:
-- [Confirm move] [The IupButton("OK") element was dragged onto IupFrame(), move as:]
--      first child of container    -- (grey out/remove if not a container) [default if]
--      last child of container     --              ""
--      previous sibling            -- (a four-way radio would probably be clearest)
--      next sibling                -- [the default on non-container targets]
-- Of course when I say non-container, that also includes any single-child-only-already-there elements.
-- QU: can we disable drop on containers dynamically? (esp IupDialog) [using CHILDCOUNTid, KINDid, PARENTid/DEPTHid?]
--******AH*****: (from IupTree.htm) [make this a <b>TIP:</b>]
--If the drop node is a branch and it is expanded, then the drag node is inserted as the first child of the node. 
--If the branch is not expanded or the node is a leaf, then the drag node is inserted as the next brother of the drop node. 
--=> Antonio,
--from IupTree, MOVENODE:
--"If the destination node is a branch and it is expanded, then the specified node is inserted as the first child of the destination node. "
--"If the branch is not expanded or the destination node is a leaf, then it is inserted as the next brother of the leaf. "
--and similarly from DRAGDROP_CB:
--"If the drop node is a branch and it is expanded, then the drag node is inserted as the first child of the node. "
--"If the branch is not expanded or the node is a leaf, then the drag node is inserted as the next brother of the drop node. "
--Problem: if the branch is empty, you cannot expand it to trigger drop as child. If the branch can only have a single child,
-- eg an IupFrame, you cannot add a dummy child so that you can expand and then drop (and then delete the dummy). It makes
-- more sense to me that a drop on an empty branch should make it a child. If you genuinely want the drop to create a 
-- sibling to an empty node (as now), I accept that change would mean you would then need to perform multiple drags, but
-- at least it wouldn't be completely impossible like the "drop as child in an empty node" currently is.
-- I believe (cmiiw) this situation also applies to and can easily be shown in IupLayoutDialog() - what I'm actually trying
-- to do is write a similar but my-programming-language-specific IDE.
--***AH*** THE PENNY FINALLY DROPS. Always add empty containers as expanded nodes. This may mean you have to add and delete
--a dummy child:
constant USETREEIMAGES = 01 -- (0 for debugging expanded/closed node settings)

--SUG (30/10/17): make a right-click menu of controls... (just to see, for now) [DONE]
--      ""      : take a hint from wpaint; that is still pretty much the user experience we want,
--                  except for the fact it is a tree/properties rather than that dropdown.
--                  (demo_controls.exw [still] worked fine)
--also blag/reuse the layout designer icon from edix.
--SUG: "spacing only" checkbox on the properties window, limits attributes to PAD/GAP/MARGIN/SIZE etc.
--[DOC] 
--  The spacing only checkbox should be self-explanatory - it lets you focus on padding, gaps, margins
--  and the like, by hiding all the other attributes such as font, colour, image, style, etc. It is in 
--  fact a tri-state toggle, with then NOTDEF state also hiding any otherwise distracting read-only 
--  attributes that you cannot actually set. Note that modifying creation-only attributes may require
--  the live-view dialog to be rebuilt, which can be forced via the Test menu option.
--  (it is a 3STATE button) 
--DOC The space checkbox (tri-state) has been disabled for this release. [DEV constant SPACE]
-- The intention is for OFF to show all attributes, ON to show just those
-- relating to spacing, and NOTDEF further restricts to those that can
-- actually be set. While the proof of concept seems to work fine, I have
-- not had time to investigate/build the lists of attributes to use. Both
-- trawling through the documents looking for likely attributes and read-only
-- markers, and running IupLayoutDialog() (eg fill.exw) would be required.

--  The Test menu option displays 7 buttons, Up, Left, Ontop, Right, Down, Rebuild, and Cancel.
--  The first five move the created window to one side, to avoid confusion that can arise when the 
--  center Ontop button is selected, in which case it overlays the existing live view window exactly. 
--  The Rebuild button simply destroys and recreates the live view, which may be necessary when you
--  modify some creation-only settings. 
--  All those 6 buttons overwrite the content of pGtest.exw, which may then be used for standard 
--  (source code) cut and paste purposes.
--  The Cancel button simply closes the Test window (as opposed to discarding any changes, which is
--  what the File/Cancel menu entry does).
--  (see ealtest.exw) ***<==*** get this working first!!

constant SHOWBRANCHINFO = 0     -- (printf(1,"IupSetAttributeId"...)
constant SHOWCONTROLS = 01      -- (printf(1,"[not] call_proc()/func()...)
--constant SHOWTABS = 0         -- (never looked right)
constant SHOWDESIRED = 0        -- (special on fill.exw)
constant SHOWDETAILS = 01       -- DEV - as you move about in the tree... (properties)
if SHOWDETAILS and SHOWDESIRED then ?9/0 end if

integer errorcount = 0

without trace
include builtins\VM\pcfunc.e
include builtins\sort.e
include builtins\utfconv.e
include builtins\VM\pprntfN.e
--include builtins\VM\psprintN.e
--with trace
include pGUI.e

with trace
--trace(3)

Ihandle hierarchytree,
--      hierarchytreE,  -- temp!(NO - NEVER REMOVE!) [DEV make this a completely separate window?]
--                      -- actually, just slap it in tree.exw - erm, better yet, slap it into
--                      -- test.exw and run it.
        properties

constant string initialcurrentdir = get_proper_dir(command_line()[2])

--
-- I really need to finish the documentation before I can do this... [DONE]
--/*
IupFill                                                                                                             [plade_fill.png]
IupNormalizer[?]                                                                                                    [plade_normal.png]
IupGridBox                                                                                                          [plade_grid.png]
IupCbox [maybe... quick and dirty...]                                                                               [plade_cbox.png]
IupHbox                                                                                                             [plade_hbox[2].png]
IupVbox                                                                                                             [plade_vbox[2/3].png]
IupZbox                                                                                                             [plade_zbox.png]
IupScrollBox                                                                                                        [plade_scroll.png]
IupBackgroundBox                                                                                                    [plade_backgroundbox.png]
IupDialog                                                                                                           [application.png]
IupButton  - Creates an interface element that is a button, that can contain a text and/or an image.                [plade_button.png]
IupFlatButton                                                                                                       [plade_flatbutton.png]
IupCanvas  - Creates an interface element that is a canvas - a working area for your application.                   [plade_canvas.png]
IupFrame  - Creates a native container, which draws a frame with a title around its child.                          [plade_frame[2].png]
IupImage[?]  - Creates an image to be shown on a label, button, toggle, or as a cursor.                             [plade_image.png]
IupLabel  - Creates a label interface element, which displays a separator, a text or an image.                      [plade_label[2].png]
IupList  - Creates an interface element that displays a list of items.                                              [plade_list.png]
IupMatrix  - Creates a matrix of alphanumeric fields.                                                               [plade_matrix.png]
IupMenu  - Creates a menu element, which groups 3 types of interface elements: item, submenu and separator.         [plade_menu.png]
IupMenuItem  - Creates an item of the menu interface element. Aka IupItem.                                          [plade_menuitem.png]
IupSeparator  - Creates the separator interface element. It shows a line between two menu items.                    [plade_sep.png]
IupSubmenu  - Creates a menu item that, when selected, opens another menu.                                          [plade_submenu.png]
IupProgressBar  - Creates a progress bar control.                                                                   [plade_progress.png]
IupPlot  - Creates a plot control.                                                                                  [plade_plot.png]
IupRadio  - Creates a void container for grouping mutual exclusive toggles.                                         [plade_radio[s].png]
IupSbox  - Creates a void container that allows its child to be resized.                                            [plade_resize.png]
IupSplit  - Creates a void container that split its client area in two.                                             [plade_split.png]
IupTabs  - Creates a tab control (like IupZbox, but interactively visibile)                                         [plade_tabs.png]
IupText  - Creates an editable text field.                                                                          [plade_text[2].png]
IupToggle  - Creates a toggle interface element                                                                     [plade_check.png]
IupTree  - Creates a tree containing nodes of branches or leaves.                                                   [plade_tree.png]
IupValuator  - Creates a Valuator control (aka Scale, Slider, or Trackbar).                                         [plade_slider.png]
IupLink (note below)                                                                                                [plade_link.png]
IupSpinBox                                                                                                          [plade_spin.png]
IupDetachBox                                                                                                        [plade_detach[2].png]
IupExpander                                                                                                         [plade_expand.png]
--IupDial   -- (removed in 3.24)                                                                                                        [plade_dial.png]
IupCells                                                                                                            [plade_cells.png]
IupCalendar                                                                                                         [plade_calendar.png]
IupDatePick                                                                                                         [plade_date_picker.png]

OMG:: I am missing a **HUGE** trick here. Just load a gui from source and leave the whole thing on the clipboard!!
That would allow you to browse for something similar, nick it, tweak it, and put it in a new project!!!!!!!
An interface to Edix might go more like (on the clipboard, or perhaps ipc shared memory):
"""
Original:
3176,21:IupDialog(vbox)
<lots more lines>
Replacement:
[3176,21:]IupDialog(vbox)
<lots more lines>
"""
And it is up to Edix to sort that mess out!! (the replacement can optionally have line/col indicating origin, but that may not help much)
-- jeez: just serialize() and deserialize(), it's exactly the sort of thing you wrote 'em for!

Instructions:
pGUI(/IUP) uses abstract layout positioning. The easiest way to think of this is that instead of using explicit x,y co-ordinates,
if you want a message with two buttons in a row beneath it, you might do something like this:
    
<!--eucode>
include pGUI.e

    IupOpen(`demo\pGUI\`)

    Ihandle text = IupLabel("Hello"),
            okbtn = IupButton("OK"),
            cancel = IupButton("Cancel"),

            hbox = IupHbox({okbtn,cancel}),
            vbox = IupVbox({text,
                            hbox}),

            dlg = IupDialog(vbox)

    IupShow(dlg)

    IupShow(dlg)

    IupMainLoop()
    IupClose()
</eucode-->
<pre>
</pre>

Which show the basic idea, but looks pretty ropey, 
<img>
until you add some padding:

<!--eucode>
include pGUI.e

    IupOpen(`demo\pGUI\`)

    Ihandle text = IupLabel("Hello"),
            okbtn = IupButton("OK"),
            cancel = IupButton("Cancel"),

            hbox = IupHbox({IupFill(),okbtn,IupFill(),cancel,IupFill()}),
            vbox = IupVbox({IupFill(),
                            IupHbox({IupFill(),text,IupFill(),IupFill()}),
                            IupFill(),
                            hbox,
                            IupLabel()}),

            dlg = IupDialog(vbox)

    IupSetAttribute(dlg, "MINSIZE", "180x120")
    IupSetAttribute(dlg, "SHRINK", "YES")

    IupShow(dlg)

    IupMainLoop()
    IupClose()
</eucode-->
<pre>
</pre>

<img>

It is in fact the need to add all those IupFill(), the extra IupHbox(), and set various attributes, that is the most
compelling reason that a program like plade is required, and what it concentrates on. Sure, (over time) there will be
a way to locate that OK button and edit/insert a template for the code that will be executed when it is clicked, but
doing so [will close plade and] plant you back in edix, hopefully with such context switches being fast and efficient
in both directions. For now, though, the focus is on getting the basic appearance right.

When plade starts, you are presented with two trees: on the left is a control palette, listing all the available
containers and elements, and on the right is a hierarchy tree, which should have an IupDialog as the root node.
Simply drag nodes from the palette onto the hierarchy (or back to the trash node), or around on the hierarchy,
and right-click on nodes on the right to set properties. Nearer the center of the screen should be a live display
reflecting changes as they happen, and you can click directly on that to assist in navigating the hierarchy tree.
In future, it may be posssible to make dragging items about on the live display automatically modify the abstract 
hierarchy tree, inserting/removing Hbox/Vbox etc as it sees fit.

Selecting a node in either the control palette or the hierarchy tree updates the corresponding help button, which 
opens the relevant page in phix.chm. Having two help buttons that do basically the same thing just makes life a
little bit easier, compared to being forced to locate and select the equivalent node on the other (palette) tree.

Aside: the split between elements and controls is quite arbitrary, as suggested by the matching icon, and was
       done simply because otherwise the element branch had too many nodes to navigate/visually scan easily.


---====---

Not supported: IupGetParam - As well as being a significant technical challenge, it would almost certainly be both physically and
                             intellectually more difficult to modify string fmt and sequence param_data in a GUI than it would be
                             to edit them in a plain text file. Considerable effort for a negative gain. Instead I might suggest
                             making a copy of demo/pGUI/getparam.exw to experiment with the layout or construct the first draft.

None of the IupGL* functions are currently supported. The samples I have might be too complex for this anyway...
-- erm, a plain IupGLCanvas is now suppoprted (mainly for CircleDraw), but IupGLButton etc are just impractical.

I am going to need lots of icons... [DONE]

note: I chose the chrome logo as it felt the most readily recognisable. 
      I suppose I should really retrieve the system html-file association... (at least on Windows/make a builtin?)

SUG: learning mode: on parse/exit show suggestions for learnt attributes and values.
                    allow accept/reject/exclude/ignore:
                    accepts are added to the drop-downs,
                    rejects trigger errors if re-encountered,
                    excludes are quietly ignored "", and
                    ignores are a one-time only thing.
    also have a learning mode default, for startup.

AHEM: we need to comprehend handles, especially for menus.  -- DONE/rework (all demos) to use IupSetAttributeHandle(),
                                                            --                    instead of IupSetHandle(), as below.
    Further, we need a list of handles used by glade itself, and auto-rename things
    when we create the dialog, so glade does not fail badly when given itself...
    (if found in the list of prohibited names, just append an X, should do it:
        if find(name,prohibited) then name &='X' end if.) [Not if we prohibit/ignore IupSetHandle!]
--*/
--sequence prohibited = {"mymenu"}
sequence prohibited = {}

--use iupnames instead??
constant IupFuncs = {"IupDialog",
                     "IupBackgroundBox",
                     "IupButton",
                     "IupFlatButton",
                     "IupCalendar",
                     "IupCanvas",
--                   "IupGLButton",
                     "IupGLCanvas",     --DEV...
--                   "IupGLCanvasBox",
--                   "IupGLExpander",
--                   "IupGLFrame",
--                   "IupGLLabel",
--                   "IupGLLink",
--                   "IupGLProgressBar",
--                   "IupGLScrollBox",
--                   "IupGLSeparator",
--                   "IupGLToggle",
--                   "IupGLVal",
                     "IupCbox",
                     "IupCells",
                     "IupClipboard",    -- (not really)
                     "IupColorDlg",     -- (not really)
                     "IupConfig",       -- (not really)
                     "IupDatePick",
                     "IupDetachBox",
--                   "IupDial",         -- (removed in 3.24)
                     "IupExpander",
                     "IupFill",
                     "IupFileDlg",      -- (not really)
                     "IupFontDlg",      -- (not really)
                     "IupFrame",
                     "IupGridBox",
                     "IupHbox",
--                   "IupImage",
--                   "IupItem", (IupMenuItem) [DEV we should really]
                     "IupLabel",
                     "IupLink",
                     "IupList",
                     "IupMatrix",
                     "IupMenu",
                     "IupMenuItem",
                     "IupMessageDlg",   -- (not really)
                     "IupMultiLine",    -- maybe..
                     "IupScrollBox",
                     "IupSeparator",
                     "IupSubmenu",
                     "IupProgressBar",
                     "IupPlot",
                     "IupRadio",
                     "IupSbox",
                     "IupSpinBox",
                     "IupSplit",
                     "IupTabs",
                     "IupText",
                     "IupToggle",
                     "IupTree",
                     "IupValuator",
                     "IupVbox",
                     "IupWebBrowser",
                     "IupZbox",
                     "Icallback"}
--?{"length(IupFuncs)",length(IupFuncs)}    -- 48 (-41=7: Icallback,IupMessageDlg,IupFontDlg,IupFileDlg,IupClipboard,IupColorDlg,IupConfig)
--?41*41    -- 1681

function nr(string name, integer rid = routine_id(name))
--DEV otherwise string gets damaged... (same may be needed for IupSetAttributeId and IupMatSetAttribute?)
--DEV (this may be the wrong place to substitute, a second [half of this] list would perhaps be better,
-- eg function ns(string name) return {name,IupProcIds[find(name,IupProcs)]}
--                                 or {name,??[find(name,??)+1]}
    if name="IupSetAttribute" then rid = routine_id("IupSetStrAttribute") end if
    return {name,rid}
end function

--DOC Note that pGUI-IDE uses IupSetStrAttribute in place of IupSetAttribute, because it does things
--    such as sprintf() all over the place, and it does not bother to try and distinguish when that
--    routine substitution is necessary, either internally or in the code it analyses. Should your
--    application mismatch that seen in pGUI-IDE, with the latter being correct, then maybe you need
--    the same substitution in your appplication code.

-- (obviously set only, we don't care about get)
constant {IupProcs,IupProcIds} = columnize({nr("IupSetAttribute"),
                                            nr("IupSetAttributes"),
                                            nr("IupSetAttributeHandle"),
                                            nr("IupSetAttributeId"),
--                                          nr("IupSetHandle"),         -- ignored?? (removed for listview.exw)
                                            nr("IupSetInt"),
                                            nr("IupSetCallback"),
                                            nr("IupMatSetAttribute"),
                                            nr("IupSetStrAttribute"),
                                            nr("IupStoreAttribute"),
                                            nr("IupAppend")})


string src = ""
--Searching for: iupdialog
-- Files scanned 61, Directories scanned 7, Lines 43042
--OK: (in samples)
--src = `demo\pGUI\fill.exw`
--OK(!!) - dozens of errors though [FIXED]
--src = `demo\edix\plade.exw`
--OK (but dull, in samples)
--src = `demo\pGUI\GraphR.exw`
--MT (good, well needs "0 windows found." and OK disabled) [DONE]
--src = `demo\pGUI\alarm.exw`
--OK (but dull, as GraphR)
--src = `demo\pGUI\buffer.exw`
--OK: (in samples)
--src = `demo\pGUI\calendar.exw`
--OK (but dull):
--src = `demo\pGUI\cdtest.exw`
--OK (in samples) - attributes:ACTIVE, RESTORE, DETACH, new_parent (1 error)[NOW SOLVED]
--src = `demo\pGUI\detachbox.exw`
--OK:
--src = `demo\pGUI\dialog2.exw`
--attributes:ACTIVE, TITLE, ORIGIN, VALUEPOS also: Icallback(cb_exit), IupAppend
--**menu broken...** (26 errors) [MENU FIXED]
--**tree broken** - IupMatrix twice, IupHbox misplaced (sibling of IupDialog) and wrong child count... [FIXED, but rubbish!]
--src = `demo\pGUI\filedump.exw`
--unresolved: attrtext, labeltext (may be a good thing) (6 errors)
--OK, after a hack:
--src = `demo\pGUI\frame.exw`
--OK, but dull. Warning - IupGLMakeCurrent/IupGLSwapBuffers/IupGLCanvasOpen not supported:
--src = `demo\pGUI\gears.exw`
--OK, but dull, as above:
--src = `demo\pGUI\glcanvas_cube.exw`
--OK (in samples):
--src = `demo\pGUI\hbox.exw`
--ish, but pGUI is not likely to cope with images, ever: --*** then again... ***
--src = `demo\pGUI\image.exw`
--OK but dull:
--src = `demo\pGUI\imgdisp.exw`
--IupGL*: (96 errors!)IupGLCanvasBox [got it down to 7 errors but then IupGLCanvasBox crashed...]
--src = `demo\pGUI\iup3Dctrls.exw`
--OK but dull:
--src = `demo\pGUI\iup3Dgl.exw`
--attribute:MARK,REDRAW,FOCUSCELL,sortc(var),SORTSIGN,TITLE,RASTERWIDTH
--sprint,sprintf etc: (24 errors)
--OK but dull
--src = `demo\pGUI\listview.exw`
--OK
--src = `demo\pGUI\list2.exw`
--OK but dull
--src = `demo\pGUI\mandelbrot.exw`
--OK (wow! - ah, test3, not test 4...) [test1: ok but dull, ditto2, 3 wow, 4: ok but dull, 4a ok but dull, 5 ok/dull, 6: ok/dull, 7:NO(OTT)
--src = `demo\pGUI\matrix.exw`
--OK, matrix3 now in samples
--src = `demo\pGUI\matrix3.exw`
--OK but dull: (IupSetHandle:[FIXED] **DEV menus should be shown but not on the hierarchy tree...)
--src = `demo\pGUI\menu.exw`
--OK (but rather dull)
--src = `demo\pGUI\multiline1.exw`
--warning - cb_run,cb_help,tab2 unresolved: (29 errors) [now 9 errors]
--NO: tab2 is in a different source! (but the error could be clearer)
--src = `demo\pGUI\pdemo.exw`
--OK: Split over multiple files... but should be able to do the amend_dlg...  [and now can!]
--24 errors...
--src = `demo\pGUI\pdemo\demo.ew`           -- OK (amend_dlg)

--not a chance! (116 errors)
--src = `demo\pGUI\plot.exw`
--OK (but dull)
--src = `demo\pGUI\plot1.exw`
--OK (in samples):
--src = `demo\pGUI\radio.exw`
--OK:
--src = `demo\pGUI\rot13.exw`
--OK (in samples)
--src = `demo\pGUI\sample.exw`
--OK but dull, experiments with MENU:
--src = `demo\pGUI\separator.exw`
--OK (in samples):
--src = `demo\pGUI\simple_notepad.exw`
--OK (once I commented out USE_OPENGL) reworked as per simple_notepad 3 dialogs (text/toolbox/main):
--src = `demo\pGUI\simple_paint.exw`
--OK but dull:
--src = `demo\pGUI\submenu.exw`
--OK (in samples):
--src = `demo\pGUI\tabs.exw`
--NO: (ifdef)
--src = `demo\pGUI\tee.exw`--:1815 atom dialog = IupDialog(vbox)
--OK (but dull)
--src = `demo\pGUI\teselation.exw`
--OK (but dull)
--src = `demo\pGUI\text.exw`
--OK (in samples) --img1,img2:
--src = `demo\pGUI\toggle.exw`
--src = `demo\pGUI\triangle.exw`                -- OK but dull
--src = `demo\pGUI\vol_fog.exw`                 -- OK but dull
--src = `demo\pGUI\webbrowser.exw`              -- OK
-- aside: "&" added so that plade.exw does not appear when filtering for these in pdemo
--src = `demo\rosetta\7`&`guis\Counter.exw`     -- OK
--src = `demo\rosetta\7`&`guis\Booker.exw`      -- OK
--src = `demo\rosetta\7`&`guis\Cells.exw`       -- OK
--src = `demo\rosetta\7`&`guis\CircleDraw.exw`  -- OK
--src = `demo\rosetta\7`&`guis\Converter.exw`   -- OK
--src = `demo\rosetta\7`&`guis\CRUD.exw`        -- OK
--src = `demo\rosetta\7`&`guis\Timer.exw`       -- OK
--DEV IupNormalizer:
--src = `demo\libcurl\manual_order.e`

sequence text
--/*
try2:
Obviously plade should understand any output it has generated. There should be no need for
separate "project" files (or the nightmare of trying to merge them). When presented with a
layout not originally generated by itself, it should offer some explanation - for instance 
if it says "warning - mymenu not resolved" then you at least have something to search for.

Likewise plade is deliberately targetted at relatively simple static layouts - complicated
dialogs that are perhaps dynamically generated from a table or file, or rely on dynamically
visible overlapping elements, and so on, are probably forver destined to be unsupported.

An important goal, for me, is to be able to find a C code snippet, translate it to Phix, and then
be able to amend the layout, and likewise should someone send me some modified source code. 
Many similar utilities require a "project" file, and if it gets even slightly out of synch the
whole thing stops working - and that kind of nonsense is most definitely not part of my plan.
That said, plade is meant, and probably forever destined, to only support relatively simple static
layouts - as soon as elements are made dynamically visible (especially when they overlap) or are
created from tables or files, this will cease to cope. A classic example can be found in this
source - constant iupnamerids etc below implement a table-driven approach to building the gui, and
populating other tables as needed, with minimal repetition, and I would consider it a great success
if glade managed to show a single blank lable/toggle in the "Controls" groupbox, in place of the 40
or so that appear when it is actually run. For me, the real purpose of glade is to get all the
containers, fillers, padding, margins, gaps, and what have you, all right and sorted, whereas the
"checkbox", "label", etc stuff (ie visible elements) is relatively trivial in my opinion.
It would also be considered acceptable to whip up a temporary layout quickly, and apply whatever
I had just learnt to the real/dynamic code.

The following limitations are noted:
1)  Obviously standard dialogs such as IupAlarm and IupFileDlg are ignored.
2)  IupSetHandle is ignored (and never generated by plade).
        A specific case is:
            IupSetHandle("menu",menu)
            IupSetAttributes(dlg,"MENU=menu")
        whereas this is fine:
            IupSetAttributeHandle(dlg,"MENU",menu)
[DEV add warnings]

Strategy:
Write new routines, based on rein/wpaint, in such a way they can replace the ones currently in rein.
Flaws: rein works directly off filetext[currfile], tabs are treated as a single space.
       This program should baulk when it finds ifdef (and IupDialog(NULL)).
       (aside: if you want any windows of plade itself to be editable, they may have to be hived off 
        into a separate file.)

Rather than make this smarter, tweak the api (ie pGUI.e) to make things easier. For instance, instead of
get_image() as used in Edix, add IupGetImage(or whatever you want to call it) so that plade can call it
too. Likewise menu_item(), if possible. And maybe fix pdemo so all the GUI is in one file.

Whitespace:
    Treat tab characters as single spaces through this program.
    When you have decided what needs updating, calculate column by treating all multiple spaces/tabs as 1,
    and when Edix applies, it does likewise, eg
        "  constant text  = `Title`"
         12345678901234567890123456
         1 23456789012345 678901234
    might attract Replace columns 19..23 (was "Title") with "Whatever", rather than columns 21..25.
    Obviously all updates are applied last to first, right to left.
    The following seem to work (not that we really need colend):

function replace_at(string s, integer col, integer colend, string oldtext, string newtext)
integer start = 0, ch
    if colend-col+1!=length(was) then ?9/0 end if
    for i=1 to col do
        start += 1
        ch = s[start]
        if ch=' ' or ch='\t' then
            for j=start+1 to length(s) do
                ch = s[j]
                if ch!=' ' and ch!='\t' then exit end if
                start = j
            end for
        end if
    end for
    ?{s[start..start+length(oldtext)-1],oldtext}
    s[start..start+length(oldtext)-1] = newtext
    return s
end function
?replace_at("  constant text  = `Title`",19,23,"Title","Whatever")

function colidx(string s, integer col)
integer res = col, ch, last='x'
    for i=1 to col do
        ch = s[i]
        if ch=' ' or ch='\t' then
            res -= (last=' ')
            ch = ' '
        end if
        last = ch
    end for
    return res
end function
?colidx("  constant text  = `Title`",21)

    

Shared memory:
Edix creates a block of shared memory, named "Edix", and sets the state to 0 (waiting), possibly along with some file that
can be used for locking (eg C:\Program Files (x86)\Phix\demo\edix\help\Phix.txt).
Other apps can write to the shared memory, setting the state to 2 (in progress) then 1 (ready), along with a specific key
(similar to eg CD_ISENS) to identify the precise contents. One message may of course be the unique name of another block
of shared memory, should Edix want/need to write back. Edix will poll for 1 and read/reset things, likewise other apps
should, especially if sending multiple messages, poll for 0 and lock and clobber.
There should be a fixed size limit that everyone has to adhere to.

enum ATTRIBUTE, CONTAINER, ELEMENT

(not entirely dissimilar to simple_paint.exw, which of course has the pixel-level handling we need)
plade: 
Menu: File (Open/Save/Test/Cancel/Exit), Edit (Undo/Redo/Properties), Tools (?), Options (?), Help (Manual, About)..
[Parse] [Designer]
Hierarchy       dialog      Containers
<------------- Elements ------------->

The Parse tab is more like filedump, showing source fragments, sortable by column, and possibly with
a drop-down list of important multi-key orderings. For use during development of plade itself.
--> Make it a pop-up window (Tools (or File or Options) menu)
There may want to be a Current tab, or maybe Replace/Insert/Delete entries on Parse will suffice.

It may be better to have Containers and Elements on the Menu (checkbox) <== Yep, do that. Or dropdown <== better.
Likewise the dialog can be standalone <== Yep, do that.

The Hierarcy is an IupTree, with full drag and drop support. Individual items can be right clicked 
on and an IupElementPropertiesDialog for them opened. Some elements (eg IupCbox) in the dialog may
also support drag and drop, some will probably not. The dialog will be a real IupDialog, constructed
dynamically. As the cursor moves around the dialog, set the focus in the IupTree, and if possible 
update the IupElementPropertiesDialog (or close and reopen in the same place).

Containers and Elements will be IupList?

SUG:
WARNING: Leaving controls with generic names (such as button1) will made code difficult to understand.
Click resume to return to the IDE and enter something more meaningful (offending control names are shown
in red), unless this is a one-off quick and dirty which will never need any maintainance (clicking ignore 
exits and saves your work, with the unhelpful generic names). [Resume] [Ignore]
-- and/or --
have/use a function that does "Load" -> "btn_load", with a clever way (isense-based?) to ensure that
btn_load does not already exist.

The aim of this program is to knock up a simple layout and get things going. It has no further ambitions 
beyond being a very simple utility of limited use at the start of a project, and will cease being useful
once you have configurable layouts, common routines to create elements, more than one variable scope, or 
code spread out over more than one source file. Most effort, and thinking, should be done elsewhere.

pGUI-IDE is usually run from Edix. You can run it standalone, but you get a warning at startup that Edix 
is not running, and errors when you exit, unless you cancel, if Edix is still not running. It is Edix 
which actually performs the save, so that you can try something and then undo it, plus Edix has run(F5) 
logic, which pGUI-IDE does not, but instead passes an F5 to Edix. Also note that pGUI-IDE does not have 
any undo logic, other than a simple "cancel all", and within Edix changes are applied, and hence undone, 
from the last line to the first, rather than chronologically or in any form of logical order.

DEV/DOC: (decision time...)
Note that opening plade from Edix causes save to transmit updates back to Edix, which can then undo/redo 
them one at a time. Conversely, opening a file from within plade causes save to directly overwrite the
file...

Once a dialog exceeds a certain complexity, or starts using clever tricks, it is likely to have outgrown 
plade and require any further modifications to be performed by hand. The real target is getting from a 
blank screen to something resembling what you want, rather than forever mollycoddling the programmer and
that way slowly turning this into a huge lumbering creaking beast. Besides, every new release of IUP is
likely to have new elements and attributes that this has no knowledge of, and you do not want to sit and
twiddle your thumbs while this plays catch up.

--DEV noe removed anyway...
IupSetAttributesf is not supported. (Obviously the dialog was not originally created via plade.) You can
try changing say btn=IupSetAttributesf(IupButton(title),xx) to btn=IupButton(title,xx), and
often such changes will require additional (local) vars and moving the element creation up a few lines.
With a bit of luck, paranormalised functions will allow btn=IupButton(..,xx) direct.  [BLIMEY, that's old.....]

--*/
--with trace
--
-- src/plscan.ew    -- (source code scanner part of plade)
-- =============
--
-- Ideally this program should only be run on programs that compile cleanly.
--  This is not a full-featured compiler, and hence there will always be 
--  some things that it does not cope particularly well with, eg:
--
--  * Generally speaking this program is designed to be able to reload any
--    code it originally wrote out. While it is impractical to attempt to
--    support any possibly pre-existing code, some limited attempts are
--    made to offer suggestions of things that would need to change.
--    (As a quick example, this might support {btnOK,btnCancel} but just
--     simply not recognise btnOK&btnCancel as being equivalent.)
--
--  * If it is not immediately obvious what some error is, try running the
--      compiler proper (possibly with -norun) against the source.
--
--  * Externally defined types. This program does not scan included files, or
--     for that matter the file(s) that include it. Hence it must sometimes
--     assume an external type and display a warning. You can specify eg:
--          --#withtype boolean
--     (strictly for the benefit of this & rein) to eliminate the warning.
--
--  * Overloaded types. While "integer integer integer = 1" is technically
--     legal, don't expect this to cope. Likewise procedure p(flag boolean)
--     where boolean is also a type, is quite likely to trip this up. (The
--     latter, being quite legal according to RDS Eu/Phix language rules, 
--     declares a /variable/ named boolean of type flag, and is nothing 
--     whatsoever to do with some previously declared boolean type.)
--
--  * This program does not recognise ifdef (which the Phix compiler only 
--      supports in a bare minimum compability fashion anyway).
--
--  * code such as
--          Ihandle frm_3 = IupFrame(..)
--          frm_3 = IupExpander(frm_3)
--      will confuse plade, which obviously cannot treat frm_3 as both an
--      IupFrame and an IupExpander. Use more (local) variables, or nest.

--
-- There are three main parts to this program:
--
-- Part 1. Tokeniser and error routines.
-- Part 2. The (highly simplified) parser.
-- Part 3. The main control routine.
--

--DEV/SUG:
--include pGPARSE.e
--or:
--include builtins/token.e

--/!*
function dequote(string s)
string res
integer ch, skip
    res = ""
    skip = 0
    for i=1 to length(s) do
        if skip then
            skip = 0
        else
            ch = s[i]
            if ch='\\' then
                skip = 1
                ch = s[i+1]
--              integer k = find(ch,"\\\"\'trn0")
                integer k = find(ch,`\"'trn0`)
                if k=0 then ?9/0 end if
--              s[i+1] = "\\\"\'\t\r\n\0"[k]
                res &= "\\\"\'\t\r\n\0"[k]
            else
--if ch='x' and i>20 then trace(1) end if
                res &= ch
--          skip = 0
            end if
        end if
    end for
    return res
end function
--*!/

--/*
function unquote(string s)
    if s[1]!='\"' then ?9/0 end if
    if s[$]!='\"' then ?9/0 end if
--  s = substitute(s[2..-2],"\\n","\n")
    s = s[2..-2]
    s = dequote(s)
    return s
end function
--*/

--
-- Part 1. Tokeniser and error routines
--

integer textlen
integer CurrLine, col, tokline, tokstart, tokend, toktype
string token
atom tokint
atom tokatm

integer returnexpr          --   1 for function/type "return <expr>",
        returnexpr = -1     --   0 for procedure "return",
                            --  -1 for toplevel statements (return is illegal)

sequence vartypes

-- (There is no particular need for these to be kept in step with ptok.e,
--  on which this was based, except that doing so may ease porting of new
--  features.)
constant SYMBOL  = 1,
         DQUOTE  = 2,
         BKTICK  = 3,   -- Back tick (string with no escape characters)
         SQUOTE  = 4,
         ELLIPSE = 5,
         HEXDEC  = 6,
         DIGIT   = 7,
         FLOAT   = 8,
         USCORE  = 9,
         LETTER  = 10,
--       SLICE   = 11,
--       SUBSCR  = 12,
         ILLEGAL = 99

--eg: {20, "IupCanvas", 159, 14,22, {{-1, "NULL", 159,24,27}}, {-1, "canvas", 159,5,10}},
--     type,name,      line,bgn,end,args,                      tgt
--     1    2          3    4   5   6                          7
--
--#without reformat
constant FUNC = 20, --DEV
             TYPE = 1,
             NAME = 2,
             IDX = 3,
             LINE = 4,
--           BEGIN = 5,
--           END = 6,
--DEV ARGS should probably be like SEQ, with all the (,,) included.
             ARGS = 7,
             TARGET = 8,
         PROC = 21,
         SEQ = -5,
--       IDENT = -1         -- or use LETTER?
         MINUS = 9,
         IDENT = 10 --LETTER    -- or use LETTER?
--SUG:   IDECL = 19         -- identifier declaration (if not aod?)
--#with reformat

--
-- The parse_data is a list of possibly relevant procedure and function calls, eg
--   IupSetAttribute() -> {PROC,"IupSetAttribute",idx,line,begin,end,args}, and
--   button = IupButton() -> {FUNC,"IupButton",idx,line,begin,end,args,target}, 
--                            where target is {IDENT,"button",0,line,begin,end}.
-- Each element of parse_data should correspond to a single statement in the source.
-- Some elements are nested, typically args is a mix of IDENT and FUNC, maybe in a SEQ.
-- The main (visual) complication is the {idx,line,begin,end} scattered throughout, which
--  will obviously be required (much later) for any subsequent update/replacement.
-- Naturally this can get quite big and ugly, and trimming down the source "source code"
--  as much as possible would be a very sensible step, should you need to debug this.
--
global sequence parse_data

--DEV not sure we really need this...
--/*
sequence insertion_points = {}

sequence insertion_point,
         next_insertion_point
         next_insertion_point = {1,1}
--*/

function setCharClass()
sequence charClass = repeat(ILLEGAL,255)
    charClass['!'] = SYMBOL
    charClass['\"'] = DQUOTE
    charClass['#'] = HEXDEC
    charClass['&'] = SYMBOL
    charClass['\''] = SQUOTE
    charClass['('..'/'] = SYMBOL    -- ()*+,-./
    charClass['.'] = ELLIPSE
    charClass['0'..'9'] = DIGIT
    charClass[':'..'?'] = SYMBOL    -- :;<=>?
--  charClass['@'] = SYMBOL
    charClass['A'..'Z'] = LETTER
    charClass['['] = SYMBOL
    charClass[']'] = SYMBOL
    charClass['_'] = USCORE
    charClass['`'] = BKTICK
    charClass['a'..'z'] = LETTER
    charClass['{'] = SYMBOL
    charClass['}'] = SYMBOL
    return charClass
end function
sequence charClass = setCharClass()

integer Ch

--DEV tokline??
procedure Abort(string msg)
    if tokline>=1 and tokline<=textlen then
        printf(1,"Error in line %d\n%s\n%s^ %s.\n",
               {tokline,
                substitute(text[tokline],"\t"," "),
                repeat(' ',tokstart-1),msg})
    else
        printf(1,"%s.\n",{msg})
        ?9/0
    end if
--?9/0
    {} = wait_key()
    abort(0)
end procedure

procedure SkipBlockComment()
-- Skip nested /!* block comments *!/
-- Note that "*!/" inside a string is interpreted as end of comment, 
--  (since it is technically text not code, and for example we must
--   treat '/!* if x="*!/" then' as '" then'), though a "/!*" and "*!/" 
--   pair (of strings/within a string) behave as expected.
-- The opening /!* has already been processed; if we cannot find a 
-- matching *!/ before EOF then display an error.
integer oline, ocol
--trace(1)
    ocol = col
    oline = CurrLine
-- if line!=0 then ?9/0 end if  -- we must maintain this!
    while CurrLine<=textlen do
        if col>=length(text[CurrLine]) then
            CurrLine += 1
            col = 1
        else
            Ch = text[CurrLine][col]
            if Ch='*' then
                if text[CurrLine][col+1]='/' then
                    col += 2
                    if col>length(text[CurrLine]) then
                        CurrLine += 1
                        col = 1
                    else
                        Ch = text[CurrLine][col]
                    end if
                    return
                end if
            elsif Ch='/' then
                if text[CurrLine][col+1]='*' then
                    col += 2
                    SkipBlockComment()
                    col -= 1
                end if
            end if
            col += 1
        end if
    end while
    tokline = oline
    tokstart = ocol
    Abort("missing closing block comment")
end procedure

procedure SkipSpacesAndComments()
-- Note: To skip "include", we just increment CurrLine and set col to 1.
--       We also set col to 1:
--          * if we fall off the end of a line (see nextCh()), and 
--          * at the very start.
--       Thus if col=1 we *must* set Ch.
sequence oneline, wtoken
integer onelen, k, l
--  insertion_point = next_insertion_point
--  next_insertion_point = {CurrLine,col}
    while 1 do -- until eof or non-blank/comment char found
        while 1 do -- until eof or non-blank line (with Ch set)
            if CurrLine>textlen then
                Ch = -1
                return
            end if
--          if next_insertion_point[2]>1 then
--              next_insertion_point = {CurrLine,1}
--          end if
            oneline = text[CurrLine]
            onelen = length(oneline)

            if col!=1 then exit end if

            if onelen>=1 then -- (equivalent to col<=onelen)
                Ch = oneline[1] -- (equivalent to Ch=oneline[col])
                exit
            end if
            CurrLine += 1
            col = 1
        end while
        if Ch=' ' or Ch='\t' then
            k = col
            while 1 do -- until Ch!=' '|'\t'
                col += 1
                if col>onelen then
                    CurrLine += 1
                    col = 1
                    exit
                end if
                Ch = oneline[col]
                if Ch!=' ' and Ch!='\t' then
                    exit
                end if
            end while
--10/07/20
--      elsif Ch='-'
        elsif find(Ch,"-/")
          and col<onelen
--        and oneline[col+1]='-' then
          and oneline[col+1]=Ch then
            -- This line is a comment (-- (or //) just found), check for
            -- --/!* (block comment) and --# directives
            if Ch='-' and col+2<onelen
            and oneline[col+2]='/'
            and oneline[col+3]='*' then
                col += 4
                SkipBlockComment()
            else
                if col+6<=onelen
                and equal(oneline[col+2..col+6],"#with") then
                    oneline = oneline[col..length(oneline)]
                    if match("--#without reformat",oneline)=1 then
--                          reformat = 0
                    elsif match("--#with reformat",oneline)=1 then
--                          reformat = 1
                    else
                        if match("--#withdef",oneline)=1 then
                            k = 11
                        elsif match("--#withtype",oneline)=1 then
                            k = 12
                        else
                            k = 0
                        end if
                        wtoken = ""
                        if k and find(oneline[k]," \t") then
                            while k<length(oneline) do
                                k += 1
                                if not find(oneline[k]," \t") then
                                    l = k+1
                                    while l<=length(oneline) do
                                        if find(oneline[l]," \t") then exit end if
                                        l += 1
                                    end while
                                    wtoken = oneline[k..l-1]
                                    exit
                                end if
                            end while
                        end if
                        if length(wtoken) then
                            if oneline[8]='d' then -- withdef
--                              if not find(wtoken,withdefs) then
--                                  withdefs = append(withdefs,wtoken)
--                              end if
                            elsif oneline[8]='t' then -- withtype
                                if not find(wtoken,vartypes) then
                                    vartypes = append(vartypes,wtoken)
                                end if
                            else
                                ?9/0
                            end if
                        elsif k then
                            Abort("a name is expected here")
                        else
                            Abort("unrecognised --#with directive")
                        end if
                    end if
                end if
                CurrLine += 1
                col = 1
            end if
        elsif Ch='/' then
            if col<onelen
            and oneline[col+1]='*' then
                col += 2
                SkipBlockComment()
            else -- (we just found a divide symbol then)
                exit
            end if
        else
            exit
        end if
    end while
end procedure

procedure nextCh()
    tokend = col-1
    if col<=length(text[CurrLine]) then
        Ch = text[CurrLine][col]
    else
        CurrLine += 1
        col = 1
    end if
    SkipSpacesAndComments()
end procedure

procedure getFloat()
-- finish off a float. The first few DIGITS (if any) have been processed;
-- continue from '.' or 'eE'
integer lenTC, exponent, esign
atom dec, fraction
sequence oneline
    oneline = text[CurrLine]
    lenTC = length(oneline)
    tokatm = tokint
    if Ch='.' then
        -- make sure it is not an ellipse
        if col<lenTC
        and text[CurrLine][col+1]='.' then
--          col -= 1
        else
            toktype = FLOAT
            dec = 1
            fraction = 0
            while 1 do
                col += 1
                if col>lenTC then exit end if
                Ch = oneline[col]
                if charClass[Ch]!=DIGIT then
                    if Ch!='_' then exit end if
                else
                    fraction = fraction*10+(Ch-'0')
                    dec *= 10
                end if
            end while
            tokatm += fraction/dec
        end if
    end if
    if find(Ch,"eE")
    and col<lenTC then
        toktype = FLOAT
        Ch = oneline[col+1]
        esign = iff(Ch='-'?-1:+1)
        if Ch='-' or Ch='+' then
            col += 1
            Ch = oneline[col+1]
        end if
        exponent = 0
        while 1 do
            col += 1
            if col>lenTC then exit end if
            Ch = oneline[col]
            if charClass[Ch]!=DIGIT then
                if Ch!='_' then exit end if
            else
                exponent = exponent*10+Ch-'0'
            end if
        end while
        tokatm = tokatm*power(10,exponent*esign)
    end if
--  token = text[CurrLine][tokstart..col-1]
    nextCh()
end procedure

constant bases = {8,16,2,10}    -- NB: oxbd order
integer base
        base = -1

procedure loadBase()
integer lenTC
sequence oneline
    oneline = text[CurrLine]
    lenTC = length(oneline)
    if base=5 then      -- 0(nn) case
        base = 0
        while 1 do
            col += 1
            if col>lenTC then exit end if
            Ch = oneline[col]
            if Ch<'0' or Ch>'9' then exit end if
            base = (base*10)+(Ch-'0')
        end while
        if base<2 or base>36 then
            Abort("unsupported number base")
        end if
        if Ch!=')' then
            Abort("')' expected")
        end if
    else
        base = bases[base]
    end if
    col += 1
    if col>lenTC then Abort("number expected") end if
    Ch = oneline[col]
    if base=8 and Ch='b' then
        col += 1
        if col>lenTC then Abort("number expected") end if
        Ch = oneline[col]
    end if
    while 1 do
        if Ch!='_' then
            if Ch>='0' and Ch<='9' and Ch<='0'+base-1 then
                Ch -= '0'
            elsif Ch>='A' and Ch<='Z' and Ch<='A'+base-11 then
                Ch -= 'A'+10
            elsif Ch>='a' and Ch<='z' and Ch<='a'+base-11 then
                Ch -= 'a'+10
            else
                exit
            end if
            tokint = tokint*base+Ch
        end if
        col += 1
        if col>lenTC then exit end if
        Ch = oneline[col]
    end while
    nextCh()
end procedure

integer mapEndToMinusOne
        mapEndToMinusOne = 0

--constant Operators={"<","<=",">",">=","=","!=",
--                  "+","+=","-","-=","*","*=",
--                  "/","/=","..","&","&="}
--DEV rename as TwoCharOps?
constant Operators = {"==",":=","<=",">=","!=","+=","-=","*=","/=","&=","@="}

function escMap(integer escChar)
    if escChar='t' then return '\t' end if
    if escChar='r' then return '\r' end if
    if escChar='n' then return '\n' end if
    if escChar='0' then return '\0' end if
    if escChar='\"' then return '\"' end if
    if escChar='\'' then return '\'' end if
    if escChar='\\' then return '\\' end if
    -- oops!
    Abort("invalid escape character")
end function

procedure getToken()
integer nxtCh, lenTC
string oneline
    if Ch=-1 then return end if
    oneline = text[CurrLine]
    tokline = CurrLine
    tokstart = col
    token = ""
    toktype = charClass[Ch]
    lenTC = length(oneline)
    if col<lenTC then
        nxtCh = oneline[col+1]
    else
        nxtCh = -1
    end if
    if toktype=LETTER then
        while 1 do
            col += 1
            if col>lenTC then exit end if
            nxtCh = charClass[oneline[col]]
            if nxtCh<DIGIT then exit end if
            if nxtCh>LETTER then exit end if
        end while
        tokend = col-1
        token = oneline[tokstart..tokend]
        if mapEndToMinusOne and equal(token,"end") then
--??    if mapEndToMinusOne=1 and equal(token,"end") then
            token = "-1"
            toktype = DIGIT
        elsif token="ifdef" then
            Abort("not supported")
        end if
        nextCh()
    elsif toktype=SYMBOL then
        if find({Ch,nxtCh},Operators) then
            col += 1
        elsif Ch='?' then
            toktype = LETTER
        end if
        col += 1
        token = text[CurrLine][tokstart..col-1]
        nextCh()
    elsif toktype=DQUOTE then
        if col+2<=lenTC
        and oneline[col+1]='\"'
        and oneline[col+2]='\"' then
--DEV should be a TQUOTE? (no line/col info)
            -- multiline (""") string. (no point doing trim handling) [??]
            token = ""
            col += 3
            while 1 do -- until closing """ found
                while col>lenTC do
                    CurrLine += 1
--                  if CurrLine>length(text) then
                    if CurrLine>textlen then
--                      Abort("missing \"\"\"")
                        Abort(`missing """`)
                        exit
                    end if
                    if length(token)!=0 then
--                      token &= '\n'
                        token &= nxtCh
                        nxtCh = '\n'
                    end if
                    oneline = text[CurrLine]
                    lenTC = length(oneline)
                    col = 1
                end while
                token &= nxtCh
                nxtCh = oneline[col]
                if nxtCh='\"'
                and col+2<=lenTC
                and oneline[col+1]='\"'
                and oneline[col+2]='\"' then
                    token &= '\"'
                    col += 3
                    exit    -- (closing """ found)
                end if
                col += 1
            end while
?{">>>>TRIPLEQUOTE",token}
            toktype = BKTICK
        else
            -- normal/traditional DQUOTE
--          token = ""
--          integer ts = tokstart
            while 1 do
                col += 1
                if col>lenTC then
--                  Abort("missing \"")
                    Abort(`missing "`)
                    exit
                end if
                nxtCh = oneline[col]
                if nxtCh='\\' then
                    col += 1
--                  nxtCh = find(oneline[col],"trn'\"\\0")
--                  if nxtCh then
--                      token &= oneline[ts..col-2]&"\t\r\n\'\"\\\0"[nxtCh]
--                      ts = col+1
--                  end if
                elsif nxtCh='\"' then
                    col += 1
                    exit
                end if
            end while
            token = oneline[tokstart..col-1]
--          token = oneline[ts..col-1]
        end if
        nextCh()
    elsif toktype=BKTICK then
--DEV ditto, not DQUOTE but BKTICK/TQUOTE, no line/col info...
        token = ""
        while 1 do
            col += 1
            while col>lenTC do  -- convert any blank lines to \n
                CurrLine += 1
--              if CurrLine>length(text) then
                if CurrLine>textlen then
                    Abort("missing `")
                    exit
                end if
                token &= '\n'
                oneline = text[CurrLine]
                lenTC = length(oneline)
                col = 1
            end while
            -- otherwise add chars unaltered, to closing tick
            nxtCh = oneline[col]
            if nxtCh='`' then
                col += 1
                exit        -- (closing ` found)
            end if
            token &= nxtCh
        end while
--      toktype = DQUOTE
        nextCh()
    elsif toktype=SQUOTE then
        if nxtCh='\\' then
            tokint = escMap(text[CurrLine][col+2])
            col += 4
        else
            tokint = text[CurrLine][col+1]
            col += 3
        end if
        nextCh()
    elsif toktype=HEXDEC then
--DEV #456ilasm?
--/* (see below)
        if col<lenTC and nxtCh='i' then
            col += 1
            nextCh()
            -- #ilasm{inline assembly},
            -- #istype{var_id,var_type}, or
            -- #isinit{var_id,0/1}.
--          toktype = ILASM
            toktype = LETTER
--DEV: (be gone ??)
            token = "#i"
            return
        end if
--*/
        tokatm = 0
        while 1 do
            col += 1
            if col>lenTC then exit end if
            nxtCh = oneline[col]
            if nxtCh!='_' then
                if nxtCh<'0' then exit end if
                if nxtCh>'9' then
                    if nxtCh<'A' then exit end if
                    if nxtCh>'F' then
                        if nxtCh<'a' then exit end if
                        if nxtCh>'f' then exit end if
                        tokatm = tokatm*16+nxtCh-'W'
                    else
                        tokatm = tokatm*16+nxtCh-'7'
                    end if
                else
                    tokatm = tokatm*16+nxtCh-'0'
                end if
            end if
        end while
-- 19/03/10 (gave up)
-- 18/07/13 (made it happen)
        if nxtCh='i' and tokstart=col-1 then
--          Abort("Sorry, #ilasm etc should be hidden from eawpaint with --/**/")
            nextCh()
            getToken()
            if toktype!=LETTER
            or not find(token,{"ilasm","ilASM"}) then
                Abort("ilASM expected")
            end if
            getToken()
            if toktype!=SYMBOL
            or not equal(token,"{") then
                Abort("{ expected")
            end if
            while 1 do
                getToken()
                if toktype=SYMBOL then
                    if equal(token,"}") then exit end if
                end if
                while find(Ch,"%@") do
                    col += 1
                    nextCh()
                end while
            end while
            getToken()
        else
            nextCh()
        end if
--      token = text[CurrLine][tokstart..col-1]
--      nextCh()
    elsif toktype=ELLIPSE then
        if nxtCh='.' then
            col += 2
--          token = text[CurrLine][tokstart..col-1]
            nextCh()
        else
            tokint = 0
            getFloat()
        end if
    elsif toktype=DIGIT then
        tokint = Ch-'0'
        if Ch='0' then  -- check for 0x/o/b/d formats
            if col<lenTC then
                Ch = oneline[col+1]
                base = find(Ch,"toxbd(")
                if base then
                    if base>1 then base -= 1 end if
                    col += 1
                    loadBase()
                    return
                end if
            end if
        end if
        while 1 do
            col += 1
            if col>lenTC then exit end if
            Ch = oneline[col]
            if charClass[Ch]!=DIGIT then
                if Ch!='_' then exit end if
            else
                tokint = tokint*10+Ch-'0'
            end if
        end while
        if find(Ch,".eE") then
            getFloat() -- (checks for ellipse)
        else
            nextCh()
        end if
    elsif toktype=ILLEGAL
      and mapEndToMinusOne
      and Ch='$' then
        mapEndToMinusOne = '$'
        token = "-1"
        toktype = DIGIT
        col += 1
        nextCh()
    else
--?9/0
        Abort("unrecognised")
    end if
--pp(token)
end procedure

procedure Match(sequence text)
    if not equal(token,text) then
        Abort(text&" expected")
    end if
    getToken()
end procedure

--
-- Part 2. The (highly simplified) parser.
--
forward function Expression()
forward procedure Block()

function DoSequence(integer vch)
-- Process a sequence
-- vch is from DoMultipleAssignment, ie/eg {a,?,b} [@]= <expr>.
--      (if non-0, both the ? and @ are allowed)
-- token=="{" on entry
integer wasMapEndToMinusOne -- allow {1,2,3,$} [==={1,2,3}]
sequence res = {}
    wasMapEndToMinusOne = mapEndToMinusOne
    mapEndToMinusOne = 1
    Match("{")
    res = {}
    while not equal(token,"}") do
        if mapEndToMinusOne='$' then
            getToken()
            exit
        end if
        mapEndToMinusOne = 0
        if vch!=0 then
            if token="?" then
                getToken()
            else
                {} = Expression()
            end if
        else
            res = append(res,Expression())
            -- Aside: this can leave us with a trailing "," instead of "}".
            res = append(res,{SYMBOL,token,0,tokline,tokstart,tokend})
            --               {TYPE,   NAME,IDX, LINE,   BEGIN,   END}
--DEV/SUG:
--          res = append(res,{SYMBOL,token,tokline,tokstart,tokend,Expression()})
        end if
        if not equal(token,",") then exit end if
        if Ch='$' then
            mapEndToMinusOne = 1
            Match(",")
            getToken()
            exit
        end if
        mapEndToMinusOne = 1
        Match(",")
    end while
    if vch!=0 then
        charClass['@'] = SYMBOL
    end if
    mapEndToMinusOne = wasMapEndToMinusOne
    Match("}")
    if token=";" then
        getToken()
    end if
    return res
end function

function Params(integer asiff)
string routinename
integer namedparams = 0
sequence res = {}
    routinename = token
--  if find(routinename,{"IupSetAttributesf","IupWebBrowser"})
--  if find(routinename,{"IupWebBrowser"})
--  or match("IupGL",routinename)=1 then
--  or 0 then
    if 0 then
        Abort("not supported")
--DEV(temp, erm, perm)
--  elsif match("IupGL",routinename)=1 then
--      printf(1,"Warning - "&routinename&" not supported\n")
    end if
    getToken()
    Match("(")
    if not equal(token,")") then
        while Ch!=-1 do
            res = append(res,Expression())
            if asiff then
                if not find(token,{",","?",":"}) then exit end if
            else
--<25/1/17> (named and defaulted parameters)
                if find(token,{":=","="}) then
                    getToken()
                    {} = Expression()
                    namedparams = 1
                elsif namedparams then
                    Match("=")  -- trigger error
                end if
--</25/1/17>
                if not equal(token,",") then exit end if
            end if
            getToken()
        end while
    end if
    if find(routinename,IupProcs) then
        res = {PROC,routinename,0,tokline,tokstart,tokend,res}
        --    {TYPE,     NAME,IDX,   LINE,   BEGIN,  END,ARGS}
        parse_data = append(parse_data,res)
--?res
--      insert_point = 1    -- mark as valid insertion point
--/*
        if Ch=-1 then
            insertion_point = next_insertion_point
        end if
        insertion_points = append(insertion_points,insertion_point)
--*/
    elsif match("IupGL",routinename)=1 
      and not find(routinename,IupFuncs) then
        printf(1,"Warning - "&routinename&" not supported\n")
    end if
    Match(")")
    return res
end function

function DoSubScripts(object res)
integer wasMapEndToMinusOne
object subscr1, subscr2
    wasMapEndToMinusOne = mapEndToMinusOne
    mapEndToMinusOne = 1
    while 1 do
        Match("[")
        subscr1 = Expression()
        if toktype=ELLIPSE then
            getToken()
            subscr2 = Expression()
--          res = {SLICE,subscr1,subscr2,res}
            res = {}
            exit
        end if
--      res = {SUBSCR,subscr1,res}
        res = {}
        if Ch!='[' then exit end if
        Match("]")
    end while
    mapEndToMinusOne = wasMapEndToMinusOne
    Match("]")
    return res
end function

procedure skip_namespace()
    if CurrLine>textlen
    or col>=length(text[CurrLine])
    or text[CurrLine][col+1]!='=' then
        getToken()
        Match(":")
    end if
end procedure

sequence tgtname = ""   -- set by Assignment
--SUG?? (for consistency would need many more {})
--       tgtpos         -- {line,begin,end}
integer tgtline = 0,
        tgtbgn = 0,
        tgtend = 0

integer treatColonAsThen = 0

function Factor()
object res
integer k
    if toktype=LETTER then
        if not treatColonAsThen then
            if Ch=':' then skip_namespace() end if
        end if
        if Ch='(' then  -- a function, we presume
            res = {FUNC,token,0,tokline,tokstart,tokend,0,0}
            --    {TYPE,NAME,IDX,LINE,BEGIN,END,ARGS,TARGET}
            if length(tgtname) then
                res[TARGET] = {IDENT,tgtname,0,tgtline,tgtbgn,tgtend}
                --            {TYPE,  NAME,IDX,   LINE, BEGIN,   END}
                tgtname = ""
--          else
--              res = res[1..ARGS]
            end if
            k = find(token,IupFuncs)
--/*
            if k!=0 then
--              insert_point = 1    -- mark as valid insertion point
                if Ch=-1 then
                    insertion_point = next_insertion_point
                end if
                insertion_points = append(insertion_points,insertion_point)
            end if
--*/
            res[ARGS] = Params(find(token,{"iff","iif"}))
--          if find(res[2],{"IupDialog","IupVbox"}) then
--          if find(res[2],IupFuncs) then   -- name
--          if find(res[NAME],IupFuncs) then
--          if k!=0 then
            if k!=0 and res[TARGET]!=0 then
                parse_data = append(parse_data,res)
--?res
--/*
--              insert_point = 1    -- mark as valid insertion point
                if Ch=-1 then
                    insertion_point = next_insertion_point
                end if
                insertion_points = append(insertion_points,insertion_point)
--*/
            end if
        else -- a variable, we presume
            res = {IDENT,token,0,tokline,tokstart,tokend}
            --    {TYPE,NAME,IDX,   LINE,   BEGIN,   END}
            getToken()
        end if
    elsif toktype=DIGIT then
        res = {DIGIT,tokint,0,tokline,tokstart,tokend}
        --    {TYPE,value,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=FLOAT then
        res = {FLOAT,tokatm,0,tokline,tokstart,tokend}
        --    {TYPE,NAME?,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=HEXDEC then
        res = {HEXDEC,tokatm,0,tokline,tokstart,tokend}
        --    {TYPE, NAME?,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=DQUOTE
       or toktype=BKTICK then   -- (or triplequote)
        -- (remove quotes)
        token = token[2..length(token)-1]
        tokstart += 1
        tokend -= 1
        if toktype=DQUOTE then
            token = dequote(token)
        end if
        res = {DQUOTE,token,0,tokline,tokstart,tokend}
        --    {TYPE, NAME,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=SQUOTE then
        res = {SQUOTE,tokint,0,tokline,tokstart,tokend}
        --    {TYPE,  NAME,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=SYMBOL and equal(token,"{") then
        res = {SEQ,token,0,tokline,tokstart,tokend}
        --    {TYPE,   NAME,IDX,   LINE,   BEGIN,   END,ARGS}
        res = append(res,DoSequence(0))
    elsif toktype=SYMBOL and equal(token,"(") then
        getToken()
        res = Expression()
        Match(")")
    else
--?9/0
        Abort("unrecognised")
        res = -1
    end if
    if toktype=SYMBOL and equal(token,"[") then
        res = DoSubScripts(res)
    end if
    return res
end function

function Unary()
object res
    if toktype=SYMBOL and equal(token,"-") then
        Match("-")
        res = {"-",Factor(),tokline,tokstart,tokend}
    elsif toktype=SYMBOL and equal(token,"+") then -- (ignore)
        Match("+")
        res = Factor()
    elsif toktype=LETTER and equal(token,"not") then
        Match(token)
        res = {"not",Factor(),tokline,tokstart,tokend}
    else
        res = Factor()
    end if
    return res
end function

function Term()
object res
    res = Unary()
    while find(token,{"*","/"}) do
        res = {token,res}
        Match(token)
        res = append(res,Unary())
    end while
    return res
end function

function Sum()
object res
    res = Term()
    while find(token,{"+","-"}) do
        res = {token,res}
        Match(token)
        res = append(res,Term())
    end while
    return res
end function

function Concat()
object res, rhs
    res = Sum()
    while equal(token,"&") do
        Match("&")
        rhs = Sum()
        if length(res)
        and res[TYPE]=DQUOTE
        and length(rhs)
        and rhs[TYPE]=DQUOTE then
            res = {DQUOTE,res[NAME]&rhs[NAME],0}    -- (no line/col info, but IDX ok)
        else
            res = {"&",res,rhs}
        end if
    end while
    return res
end function

function Relation()
object res
    res = Concat()
    while find(token,{"<","<=","=","==","!=",">",">="}) do
        res = {token,res}
        Match(token)
        res = append(res,Concat())
    end while
    return res
end function

function Expression()
object res
    res = Relation()
    while find(token,{"and","or","xor"}) do
        res = {token,res}
        Match(token)
        res = append(res,Relation())
    end while
    return res
end function
--function Expression()
--  {} = Factor()
--  while find(token,{"<","<=","=","==","!=",">",">=","*","/","+","-","and","or","xor","&","not"}) do
--      Match(token)
--      {} = Factor()
--  end while
--  return {}
--end function

procedure DoIf()    -- Process an if construct
    Match("if")
    {} = Expression()
    Match("then")
    Block()
    while equal(token,"elsif") do
        Match("elsif")
        {} = Expression()
        Match("then")
        Block()
    end while
    if equal(token,"else") then
        Match("else")
        Block()
    end if
    Match("end")
    Match("if")
end procedure

procedure DoWhile()
    Match("while")
    {} = Expression()
    Match("do")
    Block()
    Match("end")
    Match("while")
end procedure

procedure DoSwitch()
    Match("switch")
    {} = Expression()
    if find(token,{"with","without"}) then
        while Ch!=-1 do
            getToken()
            if not find(token,{"fallthru","fallthrough","jump_table"}) then exit end if
            getToken()
            if not equal(token,",") then exit end if
        end while
    end if
    if token="do" then Match("do") end if
    while Ch!=-1 do
        if find(token,{"else","default"}) then
            getToken()
        else
            Match("case")
            if find(token,{"else","default"}) then
                getToken()
            else
                treatColonAsThen = 1
                while Ch!=-1 do
                    {} = Expression()
                    if not equal(token,",") then exit end if
                    getToken()
                end while
                treatColonAsThen = 0
            end if
        end if
        if find(token,{":","then"}) then
            getToken()
        end if
        Block()
        if find(token,{"fallthru","fallthrough","break"}) then
            getToken()
        end if
        if token=";" then
            getToken()
        end if
        if equal(token,"end") then exit end if
    end while
    Match("end")
    Match("switch")
end procedure

procedure DoFor()
    Match("for")
    getToken()
    Match("=")
    {} = Expression()
    Match("to")
    {} = Expression()
    if equal(token,"by") then
        getToken()
        {} = Expression()
    end if
    Match("do")
    Block()
    Match("end")
    Match("for")
end procedure

procedure DoReturn()
    if returnexpr=-1 then Abort("return must be inside a procedure or function") end if
    Match("return")
    if returnexpr then
        {} = Expression()
    end if
end procedure

procedure DoQu()
    getToken()
    {} = Expression()
end procedure

--Now skipped in getToken()[??]
--procedure DoIlasmEtc()
--  getToken()
--  if not find(token,{"ilasm","ilASM","istype","isinit","isginfo"}) then
--      Abort("ilasm, istype, isinit, or isginfo expected")
--      return
--  end if
--  getToken()
--  Match("{")
--  while Ch!=-1 do
--      while find(Ch,":%@") do
--          col += 1
--          nextCh()
--      end while
--      getToken()
--      if equal(token,"}") then
--          getToken()
--          exit
--      end if
--  end while
--end procedure

object ares
procedure Assignment(bool allowsubscripts)
    tgtname = token
    tgtline = tokline
    tgtbgn = tokstart
    tgtend = tokend
    getToken()
    if toktype=SYMBOL and equal(token,"[") then
        if not allowsubscripts then Abort("invalid") end if
--      tgtname &= "[?]"
        tgtname = ""
        {} = DoSubScripts(0)
    end if
    if not find(token,{"=",":="}) then
        if not allowsubscripts
        or not find(token,{"+=","-=","*=","/=","&="}) then
            Abort("assignment operator expected")
        end if
        tgtname = ""
    end if
    getToken()
    ares = Expression()
end procedure

procedure DoMultipleAssignment()
--  charClass['@'] = SYMBOL
    -- [non-0 param to DoSequence() makes it allow ?,
    --  and set '@' as valid on the final Match("}")]
    {} = DoSequence('@')
    charClass['@'] = ILLEGAL
    if not find(token,{"=",":=","@="}) then
        Abort("assignment operator expected")
        return
    end if
    getToken()
    {} = Expression()
    if token=";" then
        getToken()
    end if
end procedure

procedure WarnType()
    printf(1,"Warning: %s assumed to be external type",{token})
end procedure

--constant ifforwhileetc = {"if","for","while","continue","exit","break","switch","return","end","?","#i"}
constant ifforwhileetc = {"if","for","while","continue","exit","break","switch","return","end","?","ifdef"}
constant elseetc = {"elsif","else","end","case","default","fallthru","fallthrough"}

procedure Locals()
    while toktype=LETTER do
        if not find(token,vartypes) then    -- see Note1
            if find(token,ifforwhileetc) then exit end if
            --
            if charClass[Ch]!=LETTER then exit end if
            -- ^explanation^: word word (not word =, or word[... etc) must be
            --                a variable definition (eg boolean t), not code.
            --
            WarnType()
            vartypes = append(vartypes,token)
        end if
        while 1 do
            getToken()
            if toktype=SYMBOL and equal(token,"{") then
                DoMultipleAssignment()
                if Ch!=',' then exit end if
            end if
--SUG
--          vardecs = append(vardecs,{IDECL,token,0,tokline,tokstart,tokend,Ch='='})
--          --                       {TYPE,NAME,IDX,   LINE,   BEGIN,   END,   AOD}
            if Ch='=' then
                Assignment(False)
                if toktype!=SYMBOL or token!="," then exit end if
            else
                if Ch!=',' then getToken() exit end if
                getToken()
            end if
        end while
        if token=";" then
            getToken()
        end if
    end while
end procedure

procedure DoRoutineDef(integer rType, integer fwd)
sequence sType, tType, res

    sType = token   -- procedure/function/type
    getToken()
--?token
--if token="action_cb" then trace(1) end if

--?{"DoRoutineDef",token}
    if sType="procedure" then
        if find(token,IupProcs) then
            Abort("invalid (clash with pGUI.e)")
        end if
    elsif sType="function" then
        if find(token,IupFuncs) then
            Abort("invalid (clash with PGUI.e)")
        end if
    end if
    res = {token,tokline,0}
    tType = token   -- type name
    getToken()
    Match("(")
    if not equal(token,")") then
        while Ch!=-1 do
            if Ch=':' then skip_namespace() end if
-- 22/07/2013
--          if not find(Ch,"=,") then
            if not find(Ch,"=,)") then
                if not find(token,vartypes) then
                    if charClass[Ch]!=LETTER then
                        Abort("a type is expected here")
--                      exit
                    end if
                    WarnType()
                    vartypes = append(vartypes,token)
                end if
                getToken()
            end if
--15/2/16: (unnamed params)
            if equal(token,",") then
                while 1 do
                    getToken()
                    if toktype!=SYMBOL or not equal(token,",") then exit end if
                end while
                if equal(token,")") then exit end if
            elsif equal(token,")") then
                exit
            else
                getToken()
                if find(token,{"=",":="}) then
                    getToken()
                    {} = Expression()
                end if
                if not equal(token,",") then exit end if
                getToken()
--20/11/17:
                if equal(token,")") then exit end if
            end if
--DEV positive types..
--          while Ch=',' do
--              getToken()
--              getToken()
--          end while
        end while
    end if
    Match(")")
    if fwd then return end if
    Locals()
    returnexpr = (rType>1)
    Block()
    returnexpr = -1
    Match("end")
    Match(sType)
    if rType=3 then
        vartypes = append(vartypes,tType)
    end if
end procedure

procedure Statement()
    if toktype=LETTER then
        if find(token,vartypes) then Locals()
        elsif token="if"        then DoIf()
        elsif token="for"       then DoFor()
        elsif token="while"     then DoWhile()
        elsif token="continue"  then Match("continue")
        elsif token="exit"      then Match("exit")
        elsif token="break"     then Match("break")
        elsif token="switch"    then DoSwitch()
        elsif token="return"    then DoReturn()
        elsif token="end"       then Abort("unexpected")
        elsif token="?"         then DoQu()
--      elsif token="#i"        then DoIlasmEtc()
        elsif token="ifdef"     then Abort("invalid")
        else
            if Ch=':' then skip_namespace() end if
            if Ch='(' then
                {} = Params(0)
            else
                Assignment(True)
            end if
        end if
        if equal(token,";") then
            getToken()
        end if
    elsif toktype=SYMBOL and equal(token,"{") then
        DoMultipleAssignment()
    else
--?9/0
        Abort("unrecognised")
    end if
end procedure

procedure Block()
    while 1 do
        if toktype=LETTER then
            if find(token,elseetc) then exit end if
-- 13/2/14 ("declare anywhere")
            while toktype=LETTER do
                if not find(token,vartypes) then    -- see Note1
                    if find(token,ifforwhileetc) then exit end if
                    --
                    if charClass[Ch]!=LETTER then exit end if
                    -- ^explanation^: word word (not word =, or word[... etc) must be
                    --                a variable definition (eg boolean t), not code.
                    --
                    WarnType()
                    vartypes = append(vartypes,token)
                end if
                while 1 do
                    getToken()
-- 18/6/16:
                    if toktype=SYMBOL and equal(token,"{") then
--trace(1)
                        DoMultipleAssignment()
--                      if Ch!=',' then exit end if
--                  end if
                        if token!="," then exit end if
--                      getToken()
                    else
                        if Ch='=' or Ch=':' then
                            Assignment(False)
                            if token!="," then exit end if
                        else
                            if Ch!=',' then getToken() exit end if
                            getToken()
                        end if
                    end if
                end while
                if token=";" then
                    getToken()
                end if
            end while
            if find(token,elseetc) then exit end if
            Statement()
        elsif toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
        else
            exit
        end if
    end while
end procedure

procedure TopDecls()
integer wasMapEndToMinusOne
    while Ch!=-1 do
        getToken()
        if toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
            if Ch!=',' then exit end if
        end if
        if Ch='=' then
            Assignment(False)
            if toktype!=SYMBOL or not equal(token,",") then exit end if
        else
            if Ch!=',' then getToken() exit end if
            getToken()
        end if
        if Ch='$' then
            wasMapEndToMinusOne = mapEndToMinusOne
            mapEndToMinusOne = 1
            getToken()
            mapEndToMinusOne = wasMapEndToMinusOne
            getToken()
            exit
        end if
    end while
    if token=";" then
        getToken()
    end if
end procedure

--sequence constnames = {},
--       constvals = {}
--integer constidx = 0

--integer resolvable

--with trace
--/*
function Resolve(object constval)
sequence res
integer idx
--object subscr1, subscr2, Seq
object cv1
    cv1 = constval[1]
    if cv1="+" then
        return Resolve(constval[2])+Resolve(constval[3])
    elsif sequence(cv1) then
        resolvable = 0
        return 0
    elsif cv1=IDENT then
        idx = find(constval[2],constnames)
        if idx then
            return constvals[idx]
        end if
        resolvable = 0
        return 0
    elsif cv1=FUNC then
        if equal(constval[NAME],"or_all") then
            return or_all(Resolve(constval[ARGS][1]))
        elsif equal(constval[NAME],"or_bits") then
            return or_bits(Resolve(constval[ARGS][1]),Resolve(constval[ARGS][2]))
        end if
        resolvable = 0
        return 0
--18/07/2013:
    elsif cv1=DQUOTE then
--      return constval[2][2..-2]   -- strip quotes
        return constval[2][2..$-1]  -- strip quotes
--  elsif find(cv1,{DQUOTE,SQUOTE,HEXDEC,DIGIT,FLOAT}) then
    elsif find(cv1,{SQUOTE,HEXDEC,DIGIT,FLOAT}) then
        return constval[2]
    elsif cv1=SEQ then
        res = {}
        for i=1 to length(constval[6]) by 2 do
            res = append(res,Resolve(constval[6][i]))
        end for
        return res
--  elsif cv1=SUBSCR then
--DEV this sort of works, but we can't replace it. Maybe it should be
-- {SUBSCR,{seq},{"["},{idx},{"]"}} like SEQ is.
--      if resolvable then
--          subscr1=Resolve(constval[2])
--          if resolvable and integer(subscr1) then
--              Seq=Resolve(constval[3])
--              if resolvable and sequence(Seq)
--              and subscr1>=1 and subscr1<=length(Seq) then
--                  return Seq[subscr1]
--              end if
--          end if
--      end if
--      resolvable = 0
--      return 0
--  elsif cv1=SLICE then
--DEV ditto, with ".." and {endslice}
--      if resolvable then
--          subscr1=Resolve(constval[2])
--          if resolvable and integer(subscr1) then
--              subscr2=Resolve(constval[3])
--              if resolvable and integer(subscr2) then
--                  Seq=Resolve(constval[4])
--                  if resolvable and sequence(Seq)
--                  and subscr1>=1 and subscr2<=length(Seq)
--                  and subscr2>=subscr1-1 then
--                      return Seq[subscr1..subscr2]
--                  end if
--              end if
--          end if
--      end if
--      resolvable = 0
--      return 0
    end if
--?9/0
    resolvable = 0
    return 0
end function
--*/

sequence constants,
         constvals

procedure init_constants()
    constants = {"NULL"}
    constvals = {{DIGIT,0,0}}
end procedure

procedure DoConstant()
--integer insert_point = 0
integer wasMapEndToMinusOne
    getToken()  -- discard "constant".
    while Ch!=-1 do
        if toktype=LETTER
        and find(token,vartypes)
        and (charClass[Ch]=LETTER or Ch='{') then
            -- cope with typed constant definitions, eg:
            --  constant string s = "string",
            --           integer {i,j,k} @= 0
            getToken()
        end if
        if toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
        else
            if toktype!=LETTER then ?9/0 end if
            string cname = token
            Assignment(False)
--?{"constants",cname,ares}
            constants = append(constants,cname)
            constvals = append(constvals,ares)
        end if
        if not equal(token,",") then exit end if
        if Ch='$' then
            wasMapEndToMinusOne = mapEndToMinusOne
            mapEndToMinusOne = 1
            getToken()
            mapEndToMinusOne = wasMapEndToMinusOne
            getToken()
            exit
        end if
        getToken()
    end while
--/*
    if insert_point then
        if Ch=-1 then
            insertion_point = next_insertion_point
        end if
        insertion_points = append(insertion_points,insertion_point)
    end if
--*/
    if token=";" then
        getToken()
    end if
end procedure

procedure DoEnum()
integer wasMapEndToMinusOne -- allow enum 1,2,3,$ [=== enum 1,2,3]
    wasMapEndToMinusOne = mapEndToMinusOne
    mapEndToMinusOne = 1
    Match("enum")
    while 1 do
        if mapEndToMinusOne='$' then
            getToken()
            exit
        end if
        mapEndToMinusOne = 0
        getToken()
        if equal(token,"=") then
            getToken()
            {} = Expression()
        end if
        if not equal(token,",") then exit end if
        mapEndToMinusOne = 1
        Match(",")
    end while
    mapEndToMinusOne = wasMapEndToMinusOne
end procedure

--
-- Part 3. The main control routine.
--

global procedure parse_source()
integer t
integer fwd = 0

    parse_data = {}
    CurrLine = 1
    treatColonAsThen = 0
    vartypes = {"atom","integer","bool","sequence","string","object","Ihandle","Ihandln","cdCanvas","cdCanvan","nullable_string","imImage"}
    textlen = length(text)
    if textlen
    and match("#!",text[1])=1 then  -- skip shebang
        CurrLine = 2
    end if
    col = 1
    SkipSpacesAndComments()
    getToken()
    while Ch!=-1 do
        if toktype=LETTER then
            t = find(token,{"procedure","function","type"})
            if t then
                DoRoutineDef(t,fwd)
                fwd = 0
            elsif equal(token,"constant") then
                DoConstant()
            elsif equal(token,"enum") then
                DoEnum()
            elsif find(token,{"global","public","export","override","forward"}) then
                if token="forward" then fwd = 1 end if
                getToken()  -- otherwise ignore it
            elsif find(token,{"include","with","without","namespace"}) then
                CurrLine += 1
                col = 1
                SkipSpacesAndComments()
                getToken()
            elsif token="ifdef" then
                Abort("invalid")
            else
                if Ch=':' then skip_namespace() end if
                t = find(token,vartypes)
                if not t and not equal(token,"?") then
                    if charClass[Ch]=LETTER
                    and not find(token,ifforwhileetc) then
                        -- word word (not word =, or word[... etc) /must/ be
                        --  a variable definition (eg boolean t), not code.
                        WarnType()
                        vartypes = append(vartypes,token)
                        t = length(vartypes)
                    end if
                end if
                if t then
                    TopDecls()
                else
                    if equal(token,"abort") and Ch='(' then
                        exit
                    end if
                    Statement()
                end if
            end if
        elsif toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
        else
            Abort("invalid")
            exit
        end if
    end while
--  IupMessage("ReIndent", "???")
--  ?CurrLine
    for i=1 to length(parse_data) do
        parse_data[i][IDX] = i
    end for
end procedure

-- src/rein.ew
--*!/
--/*
-- Source code scanner.
-- Builds routine lists, block start/end sets, etc.
--

--procedure appendX(sequence entry)
--integer line, k
--  line=entry[2]
--  k=length(parse_data)
--  while k and line<parse_data[k][2] do
--      k-=1
--  end while
--  if k=length(parse_data) then
--      parse_data=append(parse_data,entry)
--  else
--      parse_data=parse_data[1..k]&0&parse_data[k+1..length(parse_data)]
--      parse_data[k+1]=entry
--  end if
--end procedure

--procedure AssignOrProc()
---- Decide if a Statement is an Assignment or Procedure Call
--object Type
--integer N
----trace(1)
--  N=InAnyTable(1)
--  if N=0 then -- forward procedure call?
--      if Ch!='(' then Undefined(token) end if
--      ForwardProc(token,{'p',GetFnLn()},0)
--  else
--      Type=VarType(N)
--      if N<0 and N>=BI_BImax then --CallBuiltin(token,N,Type,"Pp")
--                                CallProc(N,Type)
--      elsif sequence(Type) then CallProc(N,Type)
--      elsif find(Type,INSPO) then Next() Assignment(N,Type)
--      else Abort("Identifier " & token & " cannot be used here")
--      end if
--  end if
--end procedure

--*/
--DEV/SUG <pGPARSE.e ends>


--constant ctrls = {
--constant {{names,rids},attrs,callbacks} = columnize({
constant {iupnamerids, cem, sigs, icons, attrs, callbacks} = columnize({
         {nr("IupBackgroundBox"),'C',"[H]AD",
                                 "plade_backgroundbox.png",
                                 {},
--"BGCOLOR[C,DLGBGCOLOR]","BORDER(co,yN)","CHILDOFFSET(0x0)","EXPAND(ni(c),ynvhvfhf,y/n(c))","CANFOCUS(NO)","CLIENTSIZE(ro,except IupDialog)"
                                 {}},
         {nr("IupButton")       ,'E',"[T]AFAD",
                                 "plade_button.png",
--"ALIGNMENT(ni,ACENTER:ACENTER)","BGCOLOR("",ignored when FLAT=YES)","CANFOCUS(co,Yn)","FLAT(co,yN)","FGCOLOR(DLGFGCOLOR)","IMAGE(ni)[H]","IMINACTIVE(ni)[H],"IMPRESS(ni)[H]",
--"IMPRESSBORDER(ni)","IMAGEPOSITION(ni,LEFT)","MARKUP(yN,gtk)","PADDING,0x0","SPACING,2","TITLE(ni)"
--"ACTIVE,Yn","FONT","EXPAND("")","SCREENPOSITION(ro,ni)","POSITION(ni,ro with expections[FLOATING=YES or inside a concrete container])",
--"MINSIZE(ni)","MAXSIZE(ni)","WID(ro,ni)","TIP(ni)","SIZE(ni)","RASTERSIZE(ni)","ZORDER(wo,ni)","VISIBLE(Yn)"
                                 {"ACTIVE","BGCOLOR","CANFOCUS","EXPAND","FLAT","IMAGE","IMPRESS","NAME","PADDING","SIZE","TIP","VISIBLE"},
                                 {"ACTION"}},
         {nr("IupFlatButton"),   'E',"[T]AFAD",
                                 "plade_flatbutton.png",
                                 {"ACTIVE","EXPAND"},
                                 {"ACTION"}},
         {nr("IupCalendar"),     'E',"AFAD",
                                 "plade_calendar.png",
                                 {"VALUE"},
                                 {"VALUECHANGED_CB"}},
         {nr("IupDatePick"),     'E',"AD",
                                 "plade_date_picker.png",
                                 {"MONTHSHORTNAMES","VALUE","ZEROPRECED"},
                                 {}},
         {nr("IupCanvas"),       'E',"AFAD",
                                 "plade_canvas.png",
                                 {"BGCOLOR","BORDER","BUFFER","DRAWSIZE","EXPAND","MARGIN","RASTERSIZE","SCROLLBAR"},
                                 {"ACTION","BUTTON_CB","MAP_CB","MOTION_CB","RESIZE_CB","UNMAP_CB"}},
--DEV (I think we need this...)
-- or just alias to IupCanvas??
         {nr("IupGLCanvas"),     'E',"AFAD",
                                 "plade_canvas.png",
                                 {"BGCOLOR","BORDER","BUFFER","DRAWSIZE","EXPAND","MARGIN","RASTERSIZE","SCROLLBAR"},
                                 {"ACTION","BUTTON_CB","MAP_CB","MOTION_CB","RESIZE_CB","UNMAP_CB"}},
--/*
         {nr("IupGLButton")     ,'E',"[T]",--AFAD",
                                 "plade_button.png",
                                 {"ACTIVE","BGCOLOR","CANFOCUS","EXPAND","FLAT","IMAGE","IMPRESS","NAME","PADDING","SIZE","TIP","VISIBLE"},
                                 {"ACTION"}},
         {nr("IupGLCanvasBox"),  'C',"[P]AFAD",
                                 "plade_canvas.png",
                                 {"MARGIN","HORIZONTALALIGN","VERTICALALIGN","EXPANDHORIZONTAL","EXPANDVERTICAL"},
                                 {}},
         {nr("IupGLExpander"),   'C',"[H]",--AD",
                                 "plade_expand.png",
                                 {"BARPOSITION","EXTRABUTTONS","TITLE"},
                                 {"ACTION","EXTRABUTTON_CB","IMAGEEXTRAid","IMAGEEXTRAPRESSid","IMAGEEXTRAHIGHLIGHTid"}},
         {nr("IupGLFrame"),      'C',"[H]",--AD",
                                 "plade_frame.png",
--                               {"ALIGNMENT","GAP","POSITION","SIZE","TITLE"},
                                 {"ALIGNMENT","POSITION","SIZE","TITLE"},
                                 {}},
         {nr("IupGLLabel"),      'E',"[T]",--AD",
                                 "plade_label.png",
                                 {"ALIGNMENT","EXPAND","FLOATING","IMAGE","MAXSIZE","NAME","PADDING","SEPARATOR","TITLE","VISIBLE"},
                                 {}},
--warning - IupGLSeparator unresolved (line 420) [errorcount +=1, line 4118]
--warning - IupGLToggle unresolved (line 403) [errorcount +=1, line 4118]
--warning - IupGLLink unresolved (line 422) [errorcount +=1, line 4118]
--warning - IupGLProgressBar unresolved (line 425) [errorcount +=1, line 4118]
--warning - IupGLVal unresolved (line 429) [errorcount +=1, line 4118]
--warning - IupGLScrollBox unresolved (line 488) [errorcount +=1, line 4118]
--*/

         {nr("IupCbox"),         'C',"[P]AD",
                                 "plade_cbox.png",
                                 {},
                                 {}},
         {nr("IupCells"),        'E',"AD",
                                 "plade_cells.png",
                                 {},
                                 {}},
         {nr("IupDetachBox"),    'C',"[H]AFAD",
                                 "plade_detach.png",
                                 {"DETACH","ORIENTATION","RESTORE"},
                                 {"DETACHED_CB"}},
--removed in 3.24:
--       {nr("IupDial"),         'E',"[O]AD",
--                               "plade_dial.png",
--                               {},
--                               {}},
         {nr("IupDialog"),       'C',"[H]AD",           --D
                                 "application.png",
--DEV RESIZE is creation only...
                                 {"BACKGROUND","CURSOR","DEFAULTENTER","DEFAULTESC","DIALOGFRAME","GAP","MARGIN","MAXBOX","MENU","MINBOX","MINSIZE",
                                  "PARENTDIALOG","RASTERSIZE","RESIZE","SHRINK","SIZE","TITLE"},
                                 {"CLOSE_CB","COPYDATA_CB","DROPFILES_CB","K_ANY","K_cV","K_cF3","K_F3","K_cG","K_cH","K_cF","K_cS","K_cO","K_cN","RESIZE_CB"}},
         {nr("IupExpander"),     'C',"[H]AD",
                                 "plade_expand.png",
                                 {"BARPOSITION","EXTRABUTTONS","TITLE"},
                                 {"ACTION","EXTRABUTTON_CB","IMAGEEXTRAid","IMAGEEXTRAPRESSid","IMAGEEXTRAHIGHLIGHTid"}},
         {nr("IupFill"),         'E',"AD",
                                 "plade_fill.png",
                                 {},
                                 {}},
--       {nr("IupFileDlg"),      'E',"",
--                               "plade_filedlg.png",   --DEV
--                               {"ALLOWNEW","DIALOGTYPE","PARENTDIALOG","TITLE"},
--                               {}},
         {nr("IupFrame"),        'C',"[H]AD",
                                 "plade_frame.png",
--                               {"ALIGNMENT","GAP","POSITION","SIZE","TITLE"},
                                 {"POSITION","SIZE","TITLE"},
                                 {}},
         {nr("IupGridBox"),      'C',"[P]AD",
                                 "plade_grid.png",
                                 {},
                                 {}},
         {nr("IupHbox"),         'C',"[P]AD",
                                 "plade_hbox.png",
                                 {"CMARGIN","FLOATING","GAP","MARGIN","NORMALIZESIZE","SIZE","TABTITLE","VISIBLE"},
                                 {}},
--       {nr("IupImage"),        'E',"WHP",
--                               "plade_image.png",
--                               {},
--                               {}},
--       {nr("IupItem"),         '?!E',"[T]AFAD",
--                               "plade_menuitem.png",
--                               {},
--                               {}},
         {nr("IupLabel"),        'E',"[T]AD",
                                 "plade_label.png",
                                 {"ALIGNMENT","EXPAND","FLOATING","IMAGE","MAXSIZE","NAME","PADDING","SEPARATOR","TITLE","VISIBLE"},
                                 {}},
         {nr("IupLink"),         'E',"[TT]AFAD",
                                 "plade_link.png",
                                 {},
                                 {}},
         {nr("IupList"),         'E',"AFAD",
                                 "plade_list.png",
                                 {"n","DROPDOWN","EDITBOX","TIP","VALUE"},
                                 {}},
         {nr("IupMatrix"),       'E',"AD",
                                 "plade_matrix.png",
                                 {"ALIGNMENT","ALIGNMENTLIN0","BORDER","CURSOR","FGCOLOR2:2","FOCUSCELL","FRAMECOLOR","HEIGHT0","HIDEFOCUS",
                                  "MARKl:c","MARKAREA","MARKED","MARKMODE","NUMCOL","NUMCOL_VISIBLE","NUMLIN","NUMLIN_VISIBLE","ORIGIN",
                                  "RASTERWIDTHn","RESIZEMATRIX","SORTSIGNn","TYPE*:1","WIDTHn","WIDTHDEF"},
                                 {"CLICK_CB","COLRESIZE_CB","ENTERITEM_CB","RELEASE_CB","VALUE_CB"}},
         {nr("IupMenu"),         'M',"[P]AD",
                                 "plade_menu.png",
                                 {},
                                 {"OPEN_CB"}},
--alias IupItem
         {nr("IupMenuItem"),     'm',"[T]AFAD",
                                 "plade_menuitem.png",
                                 {"ACTIVE","AUTOTOGGLE","IMAGE","NAME?","VALUE"},
                                 {"ACTION"}},
         {nr("IupSeparator"),    'm',"",
                                 "plade_sep.png",
                                 {},
                                 {}},
--alias IupSubMenu
         {nr("IupSubmenu"),      'M',"[TH]AD",
                                 "plade_submenu.png",
                                 {},
                                 {}},
--       {nr("IupNormalizer"),   'C',"PAD",
--                               "plade_normal.png",
--                               {},
--                               {}},
         {nr("IupProgressBar"),  'E',"AD",
                                 "plade_progress.png",
                                 {"VALUE"},
                                 {}},
         {nr("IupPlot"),         'E',"AD",
                                 "plade_plot.png",
                                 {"AXS_XCROSSORIGIN","AXS_YCROSSORIGIN","GRID","MARGIN"},
                                 {}},
         {nr("IupRadio"),        'C',"[H]AD",
                                 "plade_radio.png",
                                 {"VALUE"},
                                 {}},
         {nr("IupToggle"),       'E',"[T]AFAD",
                                 "plade_check.png",
                                 {"ACTIVE","FGCOLOR","FONT","IMAGE","IMPRESS","NAME","TIP"},
                                 {"ACTION"}},
         {nr("IupSbox"),         'C',"[H]AD",
                                 "plade_resize.png",
                                 {},
                                 {}},
         {nr("IupScrollBox"),    'C',"[H]AD",
                                 "plade_scroll.png",
                                 {},
                                 {}},
--alias IupSpinbox:
         {nr("IupSpinBox"),      'C',"[H]AD",
                                 "plade_spin.png",
                                 {},
                                 {}},
         {nr("IupSplit"),        'C',"[HH]AD",
                                 "plade_split.png",
                                 {},
                                 {}},
         {nr("IupTabs"),         'C',"[P]AD",
                                 "plade_tabs.png",
                                 {"RASTERSIZE","TABIMAGEn","TABTITLEn","TABTYPE","SIZE"},
                                 {"TABCHANGE_CB"}},
         {nr("IupText"),         'E',"AFAD",
                                 "plade_text.png",
                                 {"EXPAND","FONT","INSERT?","MASK","MULTILINE","READONLY","SELECTEDTEXT?","SELECTION?","SELECTIONPOS",
                                  "SIZE","SCROLLBAR","VALUE","VISIBLECOLUMNS","VISIBLELINES","WORDWRAP"},
                                 {"ACTION","CARET_CB","DROPFILES_CB","K_ANY","VALUECHANGED_CB"}},
         {nr("IupMultiLine"),    'E',"AFAD",
                                 "plade_textm.png",
                                 {"EXPAND","FONT","INSERT?","NAME?","SELECTEDTEXT?","SELECTION?","SELECTIONPOS","SIZE","VALUE","VISIBLECOLUMNS"},
                                 {"ACTION","CARET_CB","DROPFILES_CB","VALUECHANGED_CB"}},
         {nr("IupTree"),         'E',"AD",
                                 "plade_tree.png",
                                 {"ADDLEAFid","ADDBRANCHid","RASTERSIZE","SHOWRENAME","TITLEid"},
                                 {}},
         {nr("IupValuator"),     'E',"[O]AFAD",
                                 "plade_slider.png",
                                 {},
                                 {}},
         {nr("IupVbox"),         'C',"[P]AD",
                                 "plade_vbox.png",
                                 {"ALIGNMENT","GAP","MARGIN","POSITION","SHRINK","TABTITLE","TITLE"},
                                 {}},
         {nr("IupWebBrowser"),   'E',"",
                                 "plade_link.png",  --DEV?
                                 {"ACTIVE","FONT","EXPAND","SCREENPOSITION","POSITION","MINSIZE","MAXSIZE","WID","TIP",
                                  "RASTERSIZE","ZORDER","VISIBLE"},
                                 {}},
         {nr("IupZbox"),         'C',"[P]AD",
                                 "plade_zbox.png",
                                 {},
                                 {}},
         $})

if sequence(attrs) or sequence(callbacks) then end if   --DEV unused

--DEV finish/use:
constant {aliases,alias} = columnize({{"IupSubMenu","IupSubmenu"}})

--sigs:
--          ("IupBackgroundBox"),"[H]AD",       -- one-only (p)
--          ("IupButton")       ,"[T]AFAD",
--          ("IupFlatButton"),   "[T]AFAD",
--          ("IupCalendar"),     "AFAD",
--          ("IupDatePick"),     "AD",
--          ("IupCanvas"),       "AFAD",
--          ("IupCbox"),         "[P]AD",       -- (p)
--          ("IupCells"),        "AD",
--          ("IupDetachBox"),    "[H]AFAD",     -- one-only (p)
--  XXXX    ("IupDial"),         "[O]AD",       -- (REMOVED IN 3.24)
--          ("IupDialog"),       "[H]AD",       -- one-only [p]
--          ("IupExpander"),     "[H]AD",       -- one-only (p)
--          ("IupFill"),         "AD",
--          ("IupFrame"),        "[H]AD",       -- one-only (p)
--          ("IupGridBox"),      "[P]AD",       -- (p)
--          ("IupHbox"),         "[P]AD",       -- (p)
--X --      ("IupImage"),        "WHP",
--X --      ("IupItem"),         "[T]AFAD",
--          ("IupLabel"),        "[T]AD",
--          ("IupLink"),         "[TT]AFAD",
--          ("IupList"),         "AFAD",
--          ("IupMatrix"),       "AD",
--          ("IupMenu"),         "[P]AD",       -- [p]
--          ("IupMenuItem"),     "[T]AFAD",
--          ("IupSeparator"),    "",
--          ("IupSubmenu"),      "[TH]AD",      -- [p]
--X --      ("IupNormalizer"),   "PAD",
--          ("IupProgressBar"),  "AD",
--          ("IupPlot"),         "AD",
--          ("IupRadio"),        "[H]AD",       -- one-only (p)
--          ("IupToggle"),       "[T]AFAD",
--          ("IupSbox"),         "[H]AD",       -- one-only (p)
--          ("IupScrollBox"),    "[H]AD",       -- one-only (p)
--          ("IupSpinBox"),      "[H]AD",       -- one-only (p)
--          ("IupSplit"),        "[HH]AD",      -- two-only (p)
--          ("IupTabs"),         "[P]AD",       -- (p)
--          ("IupText"),         "AFAD",
--          ("IupMultiLine"),    "AFAD",
--          ("IupTree"),         "AD",
--          ("IupValuator"),     "[O]AFAD",
--          ("IupVbox"),         "[P]AD",       -- (p)
--          ("IupZbox"),         "[P]AD",       -- (p)


-- strip AFAD/AD, then (if not ""):
-- "[H]" - Ihandle/n    (single [HH double])
-- "[T]" - TITLE[1]/null
-- "[TT]" - URL[1]/TITLE[2]
-- "[TH]" - TITLE[1]/Ihandle/n  (single)
-- "[P]" - Ihandles
-- "[O]" - ORIENTATION[1] (nullable string. [HORIZONTAL/VERTICAL/CIRCULAR(IupDial only)])   --*** REMOVED IN 3.24 ***

--erm:
--"ACTIVE=YES,NO,Yes"
--"ALIGNMENT=ACENTER,ALEFT,ATOP,ABOTTOM"
--"ALIGNMENTLIN0=ALEFT,"
--"ALLOWNEW=YES,NO"
--"AUTOTOGGLE=YES,NO"
--`BACKGROUND="240 240 240"`
--"AXS_XCROSSORIGIN=YES,NO"
--"AXS_YCROSSORIGIN=YES,NO"
--"BARPOSITION=TOP,BOTTOM,LEFT,RIGHT"
--`BGCOLOR="128 255 0"`
--"BORDER=NO,"
--"BUFFER=DOUBLE"
--"CANFOCUS=No,"
--"CMARGIN=13x3"
--"CURSOR=ARROW"
--"CURSOR=img_cursor" (via IupSetHandle("img_cursor", img_cursor)
--"DIALOGFRAME=Yes,YES,NO"
--"DIALOGTYPE=OPEN,SAVE,DIR"
--"DROPDOWN=YES,NO"
--"EDITBOX=YES,NO"
--"EXPAND=YES,HORIZONTAL,VERTICAL,NO"
--`FGCOLOR2:2="200 0 0"`
--"FLAT=Yes,"
--"FLOATING=YES,NO,IGNORE"
--`FRAMECOLOR="220 220 220"`
--"GAP=5"
--"GRID=YES,NO"
--"HEIGHT0=10"
--"HIDEFOCUS=YES,NO"
--"ORIENTATION=VERTICAL"
--"MARKl:c=1,0" (Also via IupMatSetAttribute(matrix,"MARK", lin, 0, "Yes")
--"MARKAREA=CONTINUOUS,"
--"MARKMODE=LIN,"
--"MARGIN=10x10"
--"MASK=IUP_MASK_UINT"
--"MAXBOX=NO"
--"MAXSIZE=150"
--"MENU=mymenu" (via IupSetHandle("mymenu", IupMenu({IupSubmenu("File", file_menu)}))   <== cannot do??
-- MENU=<atom> (via IupSetAttributeHandle(hDialog,"MENU",hMenu)                         <== can do
--"MINBOX=NO"
--"MINSIZE=862x705"
--"MOVEABLE=Yes"
--"MULTILINE=YES,NO"
--"NAME=<any>"
--"NORMALIZESIZE=HORIZONTAL,VERTICAL"
--"NUMCOL=3"
--"NUMCOL_VISIBLE=3"
--"NUMLIN=13"
--"NUMLIN_VISIBLE=3"
--"PADDING=10x5"
--"PARENTDIALOG=<atom>" (via IupSetAttributeHandle(hDlg,"PARENTDIALOG",hDialog)
--"POSITION="250,350"
--"RASTERSIZE=100x150,100x,x100"    (100x=100x0,x100=0x100)
--"READONLY=YES,NO"
--"REDRAW=ALL,(L|C)n[-n]"
--"RESIZE=NO"
--"RESIZEMATRIX=YES,NO"
--"SCROLLBAR=YES,NO"
--"SEPARATOR=HORIZONTAL,VERTICAL"
--"SELECTION?=l,c:l,c|ALL"
--"SELECTIONPOS=n:n"
--"SHOWRENAME=YES,NO"
--"SHRINK=YES,NO"
--"SIZE=120[x300]"
--"SIZE=HALFxQUARTER,HALFxHALF,QUARTERxQUARTER,QUARTERxEIGHTH" (IupDialog only)
--"SORTSIGNn=NO,UP,DOWN"
--"TABTYPE=LEFT,"
--"TIP=<any>"
--"TITLE=<any>"
--"TYPE*:C=IMAGE"   (C is column; 1 etc)
--"VALUE=<any>" (ON/OFF on an IupToggle,IupMenuItem)
--"VISIBLE=YES,NO"
--"VISIBLECOLUMNS=20"
--"VISIBLELINES=5"
--"WIDTH1=60"
--"WIDTHDEF=60"
--"WORDWRAP=YES,NO"


--IupGLExpander MOVEABLE
--IupGLFrame MOVEABLE
--IupExpander TITLE only shown when BARPOSITION=TOP
--IupWebBrowser EXPAND, NAVIGATE_CB, COMPLETED_CB


--constant {{names,rids},attrs,callbacks} = columnize(ctrls)
--constant {iuprids,attrs,callbacks} = columnize(ctrls)
--constant {iupnames,iuprids} = columnize(iupnamerids)
sequence {iupnames,iuprids} = columnize(iupnamerids)

--?{"length(iupnames)",length(iupnames)}    -- 41 

--/*
procedure show_diff(sequence a, b)
    for i=length(a) to 1 by -1 do
        integer k=find(a[i],b)
        if k then
            a[i..i] = {}
            b[k..k] = {}
        end if
    end for
    ?{a,b}
end procedure

show_diff(IupFuncs,iupnames)
--*/

constant K_IupDialog = find("IupDialog",iupnames),
--       K_IupMenu   = find("IupMenu",iupnames),
--       K_IupSubmenu = find("IupSubmenu",iupnames),
--       K_IupSeparator = find("IupSeparator",iupnames),
         K_IupVbox = find("IupVbox",iupnames),
         K_IupExpander = find("IupExpander",iupnames)
--       K_IupDetachBox = find("IupDetachBox",iupnames)

function clean_sig(integer id)
    string sig = sigs[id]
    -- strip AFAD and AD suffixes:
    if  length(sig)>=4 and sig[-4..-1]="AFAD" then sig = sig[1..-5]
    elsif length(sig)>=2 and sig[-2..-1]="AD" then sig = sig[1..-3] end if
    return sig
end function

function get_max_children()
sequence res = repeat(0,length(sigs))
    for id=1 to length(sigs) do 
        integer children
        string sig = clean_sig(id)
        if find(sig,{"[H]","[TH]"}) then
            children = 1
        elsif sig="[HH]" then
            children = 2
        elsif sig="[P]" then
            children = -1
        elsif find(sig,{"","[T]","[O]","[TT]"}) then
            children = 0
        else
            ?9/0
        end if
        res[id] = children
    end for
    return res
end function

sequence max_children = get_max_children()
--hidden_kids

--  ?"=="
--  if 0 then
--  ?iupnames
--  ?iuprids
--  ?sigs
--  ?icons
--  ?attrs
--  ?callbacks
--  end if
--{} = wait_key()

--/*
--40 (all lines processed)
sequence testr = 
{{20, "IupFrame", 20,18,25,
  {{20, "IupHbox", 20,27,33,
    {{-5, "{", 20,35,35,
      {{20, "IupButton", 20,36,44, {{2, "\"Ok\"", 20,46,49}}, 0},
       {1, ",", 20,51,51}, 
       {20, "IupFill", 20,52,58, {}, 0},
       {1, "}", 20,61,61}
      }
     }
    },
    0},
   {2, `"TITLE=\"Left aligned\""`, 20,64,87}
  },
  {-1, "frame_left", 20,5,14}},
 {20, "IupFrame", 23,20,27,
  {{20, "IupHbox", 23,29,35,
    {{-5, "{", 23,37,37,
      {{20, "IupFill", 23,38,44, {}, 0},
       {1, ",", 23,47,47},
       {20, "IupButton", 23,48,56, {{2, `"Ok"`, 23,58,61}}, 0},
       {1, ",", 23,63,63},
       {20, "IupFill", 23,64,70, {}, 0},
       {1, "}", 23,73,73}
      }
     }
    },
    0},
   {2, `"TITLE=Centered"`, 23,76,91}},
  {-1, "frame_center", 23,5,16}},
 {20, "IupFrame", 26,19,26,
  {{20, "IupHbox", 26,28,34,
    {{-5, "{", 26,36,36,
      {{20, "IupFill", 26,37,43, {}, 0},
       {1, ",", 26,46,46},
       {20, "IupButton", 26,47,55, {{2, `"Ok"`, 26,57,60}}, 0},
       {1, "}", 26,62,62}
      }
     }
    },
    0},
   {2, `"TITLE=\"Right aligned\""`, 26,65,89}
  },
  {-1, "frame_right", 26,5,15}},
 {20, "IupDialog", 29,14,22,
  {{20, "IupVbox", 29,24,30,
    {{-5, "{", 29,32,32,
      {{-1, "frame_left", 29,33,42},
       {1, ",", 29,43,43},
       {-1, "frame_center", 29,44,55},
       {1, ",", 29,56,56},
       {-1, "frame_right", 29,57,67},
       {1, "}", 29,68,68}
      }
     }
    },
    0
   }
  },
  {-1, "dialog", 29,5,10}},
 {21, "IupSetAttributes", 32,55,55,
  {{-1, "dialog", 32,22,27},
   {2, "\"SIZE=120, TITLE=IupFill\"", 32,30,54}}},
 {21, "IupSetCallback", 33,59,59,
  {{-1, "dialog", 33,20,25},
   {2, "\"K_ANY\"", 33,28,34},
   {20, "Icallback", 33,37,45, {{2, "\"esc_close\"", 33,47,57}}, 0}}}}
if 0 then
    ?"parse_data:=testr"
    parse_data = testr
end if

--2770
--SUG:
-- handles = {"mymenu"}
-- handledx = {3}
--Warning about IupAppend? (in plade, vbox is subject to an Append, maybe that's where it goes...)
sequence testr2 = 
{{21, "IupSetHandle", 2605,43,43,                                                   -- 1
  {{-1, "image", 2605,30,34}, {-1, "handle", 2605,37,42}}},
 {20, "IupMenu", 2622,17,23,                                                        -- 2
  {{-5, "{", 2622,25,25,
    {{20, "IupMenuItem", 2622,26,36, {{2, "\"&Cancel\"", 2622,38,46}}, 0},
     {1, ",", 2622,48,48},
     {20, "IupSeparator", 2624,26,37, {}, 0},
     {1, ",", 2624,40,40},
     {20, "IupMenuItem", 2626,26,36,
      {{2, "\"Save and E&xit\"", 2626,38,53},
       {20, "Icallback", 2626,56,64, {{2, "\"exit_cb\"", 2626,66,74}}, 0}},
      0},
     {1, "}", 2626,77,77}}}},
  {-1, "file_menu", 2622,5,13}},
 {21, "IupSetHandle", 2628,68,68,                                                   -- 3
  {{2, "\"mymenu\"", 2628,18,25},
   {20, "IupMenu", 2628,28,34,
    {{-5, "{", 2628,36,36,
      {{20, "IupSubmenu", 2628,37,46,
        {{2, "\"File\"", 2628,48,53}, {-1, "file_menu", 2628,56,64}}, 0},
       {1, "}", 2628,66,66}}}},
    0}}},
 {20, "IupVbox", 2630,20,26, {{-5, "{", 2630,28,28, {}}},                           -- 4 c
  {-1, "vbox", 2630,13,16}},
 {20, "IupRadio", 2631,21,28, {{-1, "vbox", 2631,30,33}},                           -- 5 c
  {-1, "radio", 2631,13,17}},
 {20, "IupLabel", 2636,23,30, {{2, "\"NULL\"", 2636,32,37}},                        -- 6 (only used via IupAppend)
  {-1, "lbl", 2636,17,19}},
 {21, "IupSetStrAttribute", 2637,57,57,                                             -- 7
  {{-1, "lbl", 2637,28,30}, {2, "\"IMAGE\"", 2637,33,39},
   {20, "get_image", 2637,42,50, {{-1, "icon", 2637,52,55}}, 0}}},
 {20, "IupToggle", 2638,23,31, {{-1, "iupname", 2638,33,39}},                       -- 8 (only used via IupAppend)
  {-1, "tgl", 2638,17,19}},
 {21, "IupAppend", 2670,66,66,
  {{-1, "vbox", 2670,19,22},
   {20, "IupHbox", 2670,24,30,
    {{-5, "{", 2670,32,32,
      {{-1, "lbl", 2670,33,35}, {1, ",", 2670,36,36},
       {-1, "tgl", 2670,37,39}, {1, "}", 2670,40,40}}},
     {2, "\"NORMALSIZE=HORIZONTAL\"", 2670,42,64}}, 0}}},
 {21, "IupSetAttributeHandle", 2641,52,52,                                          -- 9
  {{-1, "radio", 2641,35,39}, {2, "\"VALUE\"", 2641,41,47},
   {-1, "tgl", 2641,49,51}}},
 {20, "IupFrame", 2645,21,28,                                                       -- 10
  {{-1, "radio", 2645,30,34},
   {2, "\"TITLE=Controls, PADDING=5x\"", 2645,36,63}},
  {-1, "frame", 2645,13,17}},
 {20, "IupDialog", 2648,11,19,                                                      -- 11
  {{20, "IupHbox", 2648,21,27,
    {{-5, "{", 2648,29,29,
      {{-1, "frame", 2648,30,34},
       {1, ",", 2648,35,35},
       {20, "IupFill", 2648,36,42, {}, 0},
       {1, "}", 2648,45,45}}},
     {2, "\"MARGIN=5x\"", 2648,47,57}}, 0},
   {2, "\"MENU=mymenu, SIZE=250x370\"", 2649,21,47}},
  {-1, "dlg", 2648,5,7}},
 {21, "IupSetAttribute", 2650,65,65,                                                -- 12
  {{-1, "dlg", 2650,21,23}, {2, "\"TITLE\"", 2650,26,32},
   {2, "\"plade - Phix Layout Designer\"", 2650,35,64}}},
 {21, "IupSetCallback", 2651,56,56,                                                 -- 13
  {{-1, "dlg", 2651,20,22}, {2, "\"K_ANY\"", 2651,25,31},
   {20, "Icallback", 2651,34,42, {{2, "\"esc_close\"", 2651,44,54}}, 0}}}}
if 0 then
    ?"parse_data:=testr2"
    parse_data = testr2
end if
--*/
--"=="
--/*
dialogs: {11}
--       1 2 3  4  5 6 7 8  9 10 11 12 13
dialog: {0,0,0,11,11,0,0,0,11,11,11,11,11}
dlevel: {0,0,0, 4, 3,0,0,0, 3, 2, 1, 1, 1}
names: {"file_menu","vbox","radio","lbl","tgl","frame","dlg"}
namedx: {2,4,5,6,8,10,11}
children: {{},{},{},{},{4},{},{},{},{},{5},{10},{},{}}
--*/
--"=="

--DEV/SUG:
--include pG??, or make part of pGPARSE.e?

sequence dialogs, dialoglines, names, namedx

--sequence dialogs = {}
--sequence dialoglines = {}
--sequence names = {},
--       namedx = {}

--sequence clean    --DEV incomplete
--sequence trees
--DEV setup later??
sequence children, updates, dialogN, dlevel
--sequence children = repeat({},length(parse_data))
--sequence updates = repeat({},length(parse_data))
--sequence dialogN = repeat(0,length(parse_data)) -- DEV to go? (not as useful as I thought? [may yet have use in clash avoidance])
--sequence dlevel = repeat(0,length(parse_data))    -- DEV to go? (not as useful as I thought)

--function mark_dialog(integer d, integer di, sequence ri, integer level)
procedure mark_dialog(integer d, integer di, sequence ri, integer level)
integer k, kdx
string name
--sequence childrenL = {}
--?{"mark_dialog",d,di,ri,level}
    if ri[TYPE]!=FUNC then ?9/0 end if
    -- ri is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
    if dialogN[di]!=0
    and dialogN[di]!=d then
?"?? errorcount +=1 line 2776"
        dialogN[di]=-1
--      return 0
        errorcount += 1
    else
        dialogN[di] = d
        dlevel[di] = level
--?{dialogN,dlevel}
        sequence args = ri[ARGS]
        for i=1 to length(args) do
            sequence argi = args[i]
--          integer aitype = argi[TYPE]
            object aitype = argi[TYPE] -- (can be eg "&")
            if aitype=FUNC then
                -- argi is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
--              childrenL = append(childrenL,mark_dialog(d,di,argi,level))
--              childrenL &= mark_dialog(d,di,argi,level)[2]
                mark_dialog(d,di,argi,level)
            elsif aitype=SEQ then
                -- argi is {TYPE=SEQ,NAME="{",LINE,BEGIN,END,ARGS}
                --         (where LINE,BEGIN,END locate the source "{")
                if argi[NAME]!="{" then ?9/0 end if
                if length(argi)!=ARGS then ?9/0 end if
                argi = argi[ARGS]
                -- argi is {[odd,{",",odd}],"}"}
                -- where "," and "}" are really {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
                --  (and odd are as per argii with and_bits(ai,1)=1 below)
                --  (actually, a trailing "," is also allowed (and no "}"), for ",$" etc.)
                if and_bits(length(argi),1) then ?9/0 end if
                for ai=1 to length(argi) do
                    sequence argii = argi[ai]
                    name = argii[NAME]
                    if and_bits(ai,1)=1 then
                        aitype = argii[TYPE]
                        if aitype=IDENT then
                            -- argii is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                            k = find(name,names)
if k=0 or not integer(namedx[k]) then
                            if not find(name,{"NULL"}) then
--DEV defer to a messagebox:
--                              puts(1,"warning - "&name&" unresolved\n")
                                printf(1,"warning - %s unresolved (line %d), errorcount +=1, [3186]\n",{name,argii[LINE]})
                                errorcount += 1
                            end if
else
                            kdx = namedx[k]
--if kdx=50 then ?9/0 end if
                            children[di] &= kdx
--                          childrenL = append(childrenL,mark_dialog(d,kdx,parse_data[kdx],level+1))
                            mark_dialog(d,kdx,parse_data[kdx],level+1)
end if
                        elsif aitype=FUNC then
                            -- argii is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
--                          childrenL = append(childrenL,mark_dialog(d,di,argii,level))
--                          childrenL &= mark_dialog(d,di,argii,level)
                            mark_dialog(d,di,argii,level)
                        else
--DEV no/temp/...?
                            ?9/0
                        end if
                    else
                        if argii[TYPE]!=SYMBOL then ?9/0 end if
                        -- argii is {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
--28/2/17
--                      if ai<length(argi) then
--                          if name!="," then ?9/0 end if
--                      else
--                          if name!="}" then ?9/0 end if
--                      end if
                        if name!="," then
                            if ai<length(argi) then ?9/0 end if
                            if name!="}" then ?9/0 end if
                        end if
                    end if
                end for
            elsif aitype=IDENT then
                -- argi is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                name = argi[NAME]
                k = find(name,names)
                if k=0 or not integer(namedx[k]) then
--21/11/17: (may be desired elsewhere)
--                  if not find(name,{"NULL"}) then
                    k = find(name,constants)
                    if k=0 then
--DEV defer to a messagebox:
--                      puts(1,"warning - "&name&" unresolved\n")
                        printf(1,"warning - %s unresolved (line %d), errorcount +=1, [3197]\n",{name,argi[LINE]})
                        errorcount += 1
                    end if
                else
                    kdx = namedx[k]
--if kdx=50 then ?9/0 end if
                    children[di] &= kdx
--                  childrenL = append(childrenL,mark_dialog(d,kdx,parse_data[kdx],level+1))
                    mark_dialog(d,kdx,parse_data[kdx],level+1)
                end if
--          elsif aitype="&" then
--              -- argi = {TYPE="&",lhs,rhs}
----DEV we should glue these together ourselves...
--              if argi[2][TYPE]!=DQUOTE
--              or argi[3][TYPE]!=DQUOTE then
--                  ?argi
--              end if
            elsif aitype!=DQUOTE then
                -- (argi!={TYPE=DQUOTE,NAME[,LINE,BEGIN,END]})
--DEV unknown/error
                ?argi
            end if
        end for
    end if
end procedure
--?{di,childrenL}
--  return {di,childrenL}
--end function

procedure anaylse()
string name
integer k, kdx, di
sequence ri, arg1

    dialogs = {}
    dialoglines = {}
    names = {}
    namedx = {}
    children = repeat({},length(parse_data))
    updates = repeat({},length(parse_data))
    dialogN = repeat(0,length(parse_data))
    dlevel = repeat(0,length(parse_data))   -- DEV to go? (not as useful as I thought)

    for i=1 to length(parse_data) do
        ri = parse_data[i]
        if ri[TYPE]=FUNC then
            -- ri is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
            if ri[NAME]="IupDialog" then
                dialogs = append(dialogs,i)
                dialoglines = append(dialoglines,ri[LINE])
            end if
            if ri[TARGET][TYPE]!=IDENT then ?9/0 end if
            -- ri[TARGET] is {TYPE=IDENT,NAME,LINE,BEGIN,END}
            name = ri[TARGET][NAME]
            k = find(name,names)
            if k!=0 then
--              namedx[k] = -1
                namedx[k] = append(namedx[k],i)
            else
                names = append(names,name)
                namedx = append(namedx,i)
            end if
        end if
    end for
--  clean = repeat(1,length(dialogs))   --DEV incomplete
--  dialogN = repeat(0,length(parse_data))
--  dlevel = repeat(0,length(parse_data))
--  trees = repeat(0,length(dialogs))

    for i=1 to length(dialogs) do
        di = dialogs[i]
--      clean[i] = 
--      trees[i] = mark_dialog(di,di,parse_data[di],1)
        mark_dialog(di,di,parse_data[di],1)
    end for
    integer rescan = 0
    for i=1 to length(parse_data) do
        ri = parse_data[i]
        if ri[TYPE]=PROC then
            -- ri is {TYPE=PROC,NAME,LINE,BEGIN,END,ARGS}
            arg1 = ri[ARGS][1]
            if length(arg1)>0
            and arg1[TYPE]=IDENT then
                -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                name = arg1[NAME]
                k = find(name,names)
                if k=0 or not integer(namedx[k]) then
                    if not find(name,{"NULL"}) then
--DEV defer to a messagebox:
--                      puts(1,"warning - "&name&" unresolved[4]\n")
                        integer iserr = 1
                        if find(ri[NAME],{"IupSetAttribute",
                                          "IupSetAttributes",
                                          "IupSetAttributeId",
                                          "IupSetInt",
                                          "IupMatSetAttribute",
                                          "IupSetStrAttribute",
                                          "IupAppend",
                                          "IupStoreAttribute",
                                          "IupSetAttributeHandle",
                                          "IupSetCallback"}) then
                            iserr = 0
                        end if
                        string erm = iff(iserr?", errorcount +=1":"")
                        printf(1,"warning - %s unresolved (line %d)%s, [3311]\n",{name,arg1[LINE],erm})
                        errorcount += iserr
                    end if
                else
                    kdx = namedx[k]
                    dialogN[i]=dialogN[kdx]
                    dlevel[i]=dlevel[kdx]
--                  updates[i] &= kdx
--if i=1 then ?9/0 end if
                    updates[kdx] &= i
                end if
--          else
--              ?9/0
            end if
            name = ri[NAME]
            if name="IupAppend" then
--DEV now seems fine, sometimes... (but not on IupPlot.exw!)
--?"IupAppend [errorcount +=1, line 2955]"
--errorcount += 1
printf(1,"Warning - IupAppend (line %d) [3328]\n",{ri[LINE]})
                arg1 = ri[ARGS][2]
                if length(arg1)=0 then
                    ?{"arg1={} line 3333",ri[LINE]}
                elsif arg1[TYPE]=IDENT then
                    -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                    name = arg1[NAME]
                    k = find(name,names)
                    if k!=0 then
                        kdx = namedx[k]
                        dialogN[i]=dialogN[kdx]
                        dlevel[i]=dlevel[kdx]
-- untried:
--                      updates[i] &= kdx
--                      updates[kdx] &= i
?{"updates, line 3342",kdx,i}
                    end if
                elsif arg1[TYPE]=FUNC then
                    -- arg1 is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
                    di = dialogN[i]
if di!=0 then
                    mark_dialog(di,di,arg1,dlevel[i])
end if
                    rescan = 1
--              else
--                  ?9/0
                end if
--/*                
 {21, "IupAppend", 2670,66,66,
  {{-1, "vbox", 2670,19,22},
   {20, "IupHbox", 2670,24,30,
    {{-5, "{", 2670,32,32,
      {{-1, "lbl", 2670,33,35}, {1, ",", 2670,36,36},
       {-1, "tgl", 2670,37,39}, {1, "}", 2670,40,40}}},
     {2, "\"NORMALSIZE=HORIZONTAL\"", 2670,42,64}}, 0}}},
--*/
--              ?9/0
            elsif name="IupSetAttributeHandle" then
                arg1 = ri[ARGS][1]
--              arg1 = ri[ARGS][3]
                if arg1[TYPE]=IDENT then
                    -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                    name = arg1[NAME]
                    k = find(name,names)
                    if k=0 or not integer(namedx[k]) then
                        if not find(name,{"NULL"}) then
--DEV defer to a messagebox:
--                          puts(1,"warning - "&name&" unresolved[4]\n")
--                          printf(1,"warning - %s unresolved (line %d) [errorcount +=1, line 3342]\n",{name,arg1[LINE]})
--                          errorcount += 1
                            printf(1,"warning - %s unresolved (line %d) [3394]\n",{name,arg1[LINE]})
                        end if
                    else
                        kdx = namedx[k]
                        di = kdx
--?di -- 17
--                      dialogN[i]=dialogN[kdx]
--                      dlevel[i]=dlevel[kdx]
--                      updates[i] &= kdx
--                      updates[kdx] &= i
                        arg1 = ri[ARGS][2]
                        if arg1[TYPE]=DQUOTE then
                            -- argi={TYPE=DQUOTE,NAME[,LINE,BEGIN,END]}
                            if arg1[NAME]="MENU" then
                                arg1 = ri[ARGS][3]
                                if arg1[TYPE]=IDENT then
                                    -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                                    name = arg1[NAME]
                                    k = find(name,names)
                                    if k!=0 then
                                        kdx = namedx[k]
--16:
                                        dialogN[kdx]=dialogN[di]
                                        dlevel[kdx]=dlevel[di]
--                                      updates[di] &= kdx
--if kdx=50 then ?9/0 end if
                                        children[di] &= kdx
                                        arg1 = parse_data[kdx]
--?arg1
                                        if arg1[TYPE]=FUNC then
                                            -- arg1 is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
--                                          di = dialogN[kdx]
--                                          mark_dialog(di,di,arg1,dlevel[di])
                                            mark_dialog(di,kdx,arg1,dlevel[di])
                                            rescan = 1
                                        end if
                                    end if
                                end if
                            end if
                        end if
                    end if
--              else
--                  ?9/0
                end if
            end if
        end if
    end for
    if rescan then
        for i=1 to length(parse_data) do
            if dialogN[i]=0 then
                ri = parse_data[i]
                if ri[TYPE]=PROC then
                    -- ri is {TYPE=PROC,NAME,LINE,BEGIN,END,ARGS}
                    arg1 = ri[ARGS][1]
                    if length(arg1)>0
                    and arg1[TYPE]=IDENT then
                        -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                        name = arg1[NAME]
                        k = find(name,names)
                        if k!=0 and integer(namedx[k]) then
                            kdx = namedx[k]
                            dialogN[i]=dialogN[kdx]
                            dlevel[i]=dlevel[kdx]
--                          updates[i] &= kdx
--if i=1 then ?9/0 end if
if not find(i,updates[kdx]) then
                            updates[kdx] &= i
end if
                        end if
                    end if
                end if
            end if
        end for
    end if

--/*
    -- finally, a little helper display:
    string cud = repeat('?',length(parse_data))
    for i=1 to length(parse_data) do
        for j=1 to length(children[i]) do
            integer c = children[i][j]
--          cud[c] = 'c'
--          cud[c] = iff(dialogN[c]=i?'c':'C')
            cud[c] = iff(dialogN[c]=dialogN[i]?'c':'C')
        end for
        for j=1 to length(updates[i]) do
            integer u = updates[i][j]
--          cud[u] = 'u'
--          cud[u] = iff(dialogN[u]=i?'u':iff(dialogN[u]=0?'-':'U'))
--          cud[u] = iff(dialogN[u]=dialogN[i]?'u':iff(dialogN[u]=0?'-':'U'))
            cud[u] = iff(dialogN[u]=0?'-':iff(dialogN[u]=dialogN[i]?'u':'U'))
        end for
    end for
    for i=1 to length(dialogs) do
        integer d = dialogs[i]
--      cud[d] = 'd'
        cud[d] = iff(dialogN[d]=d?'d':'D')
    end for
--*/

    puts(1,"dialogs: ")     ?dialogs
    puts(1,"dialoglines: ") ?dialoglines
    puts(1,"dialogN: ")     ?dialogN
    puts(1,"dlevel: ")      ?dlevel
--  puts(1,"clean: ")       ?clean
--  puts(1,"trees: ")       ?trees
    puts(1,"names: ")       ?names
    puts(1,"namedx: ")      ?namedx
    puts(1,"children: ")    ?children
    puts(1,"updates: ")     ?updates
--  puts(1,"cud: ")         ?cud
--  pp(trees,{pp_Nest,10})
end procedure


-- parse attribute strings as passed to IupSetAttributes etc
--  (code translated from the C internals of IUP itself)

string attr_str
integer asdx

string ap_res

procedure iAttribCapture(string delims)
integer i = 0, c
    ap_res = ""
    while asdx<=length(attr_str) do
        c = attr_str[asdx]
        asdx += 1
        if find(c,delims) then
            asdx -= 1
            exit
        end if
        if (i<256) then
            ap_res &= c
        end if
    end while
end procedure

procedure iAttribSkipComment()
integer c = 0
    while asdx<=length(attr_str) and c!='\n' do
        c = attr_str[asdx]
        asdx += 1
    end while
end procedure

enum TK_END, TK_SET, TK_COMMA, TK_NAME

function iAttribToken()
    while 1 do
        if asdx>length(attr_str) then return TK_END end if
        integer c = attr_str[asdx]
        asdx += 1
--      if find(c,"#%") then
        if find(c,"#") then
            iAttribSkipComment();
        elsif not find(c," \t\n\r") then
            switch c do
                case '=':
                    return TK_SET
                case ',':
                    return TK_COMMA
                case '\"':
--                  iAttribCapture("\"")    -- string
                    iAttribCapture(`"`)	-- string
                    asdx += 1
                    return TK_NAME
                default:
                    if c>' ' then
                        -- identifier
                        asdx -= 1
                        iAttribCapture("=, \t\n\r")
                        return TK_NAME
                    end if
            end switch
        end if
    end while
end function

--DEV global function iup_parse_attributes, in pGUI.e itself:
function parse_attributes(string attribute_string)
sequence names = {}, vals = {}
string name = "", val
integer state = 'a'     -- get attribute

    attr_str = attribute_string
    asdx = 1
    if length(attr_str)!=0 then
        if find('=',attr_str)=0 then ?9/0 end if
    end if

    while 1 do
        integer tk = iAttribToken()
        switch tk do
            case TK_END,
                 TK_COMMA:
                if length(name) then
                    names  = append(names,name)
                    vals = append(vals,val)
                end if
                if tk=TK_END then exit end if
                name = ""
                val = ""
                state = 'a'

            case TK_SET:
                state = 'v' -- get value
            case TK_NAME:
                if state=='a' then
                    name = ap_res
                else
                    val = ap_res
                end if
        end switch
    end while
    return {names,vals}
end function

--?parse_attributes("")
----trace(1)
--?parse_attributes(`SIZE=40x50, TITLE="First Name"`) -- {{"SIZE","TITLE"},{"40x50","First Name"}}

function get_image(string image)
-- images are loaded from the icons subdirectory (demo/edix/icons/xxx.png).
--  ( almost of them were obtained from http://www.iconarchive.com )
nullable_string res

    if length(image)=0 then
        res = NULL
    elsif platform()=WINDOWS
      and IupGetHandle(image)!=NULL then    -- (already loaded)
        res = image
    else
        string path = join_path({initialcurrentdir,"icons",image})
        if platform()=WINDOWS then

            -- use IM library to load image
            Ihandln handle = IupLoadImage(path)
            if handle=NULL then
--?path
                res = NULL
            else
                -- store the image handle
--erm??
--              if not find(image,prohibited) then ?9/0 end if
                prohibited = append(prohibited,image)
                IupSetHandle(image, handle)
                return image
            end if
        else -- LINUX
            -- natively supports PNG images
            res = path
        end if
    end if
    return res
end function

--DEV POSITION not on IupDialog (or maybe it is..)
--    SCREENPOSITION not on IupVbox, IupRadio, IupGridBox
--    CLIENTOFFSET only for IupFrame, IupTabs and IupDialog (/containers only) read-only
--    CLIENTSIZE read-only except on IupDialog, containers only
--constant IPROPS = {"SIZE","RASTERSIZE","FLOATING"}
--"USERSIZE"    -- blank on everything???

function iprops(integer funcdx)
--, sequence args)
--sequence res = IPROPS
sequence res = {"SIZE","RASTERSIZE","FLOATING","VISIBLE"}
    if upper(cem[funcdx])='C' then
        res &= {"CLIENTSIZE","CLIENTOFFSET"}
    end if
    if iupnames[funcdx]!="IupDialog" then
        res &= {"POSITION"}
    end if
    if iupnames[funcdx]="IupDialog"
    or iupnames[funcdx]="IupFrame"
    or iupnames[funcdx]="IupTabs"
    or upper(cem[funcdx])='E' then
        res &= {"SCREENPOSITION"}
    end if
    string sig = clean_sig(funcdx)
    if iupnames[funcdx]="IupDialog"
    or iupnames[funcdx]="IupExpander"
    or iupnames[funcdx]="IupFrame"
    or iupnames[funcdx]="IupPlot"
    or find(sig,{"[T]","[TH]"}) then
--?{"args[3804]",args}
--DEV this sort of thing is probably more appropriate in the write-back phase...
--      if length(args)>=1 
--      and string(args[1])
--      and args[1]!="" then
            res = append(res,"TITLE")
--      end if
    elsif sig="[TT]" then
        res = append(res,"URL")
        res = append(res,"TITLE")
    elsif sig="[O]" then
        res = append(res,"ORIENTATION")
    end if
    return res
end function

if 0 then
    for i=1 to length(iupnames) do
        sequence s = iprops(i)
        if not find("TITLE",s)
        and upper(cem[i])!='M'
        and not find(iupnames[i],{"IupBackgroundBox","IupFill","IupMatrix","IupTabs","IupTree"}) then
            ?iupnames[i]
        end if
    end for
    {} = wait_key()
    abort(0)
--/*
"IupCalendar"
"IupDatePick"
"IupCanvas"
"IupCbox"
"IupCells"
"IupDetachBox"
"IupDial"           -- REMOVED IN 3.24
"IupGridBox"
"IupHbox"
"IupList"
"IupProgressBar"
"IupRadio"
"IupSbox"
"IupScrollBox"
"IupSpinBox"
"IupSplit"
"IupText"
"IupMultiLine"
"IupValuator"
"IupVbox"
"IupZbox"
--*/
end if

sequence all_handles,
         all_tags = {},     -- (ensure mouseover checks children first)
         all_funcdx,
         all_properties,
         handles

integer lastbranch, lastnode

forward function create_control(integer i, sequence pdi, integer pid, bool aschild)

bool allargsvalid

with trace
function resolve_arg(integer adx, sequence arg, integer pid, bool aschild, sequence pdi)
object res
integer k, kdx
--, aitype
string name
integer newpid
integer iserr
string erm
--?{"resolve_arg",arg}

--for eg: (DEV this can be improved!)
--{"resolve_arg",{"-",{10,"l",0,318,44,44},{7,1,0,318,46,46}},"(allargsvalid:=false), errorcount+=1 line 3530"}
    if length(arg)=3 and arg[TYPE]="-" then
        arg[TYPE] = MINUS
    end if

--  if length(arg)=0
--  or not integer(arg[TYPE]) then
--  if length(arg)={} then return {} end if
--  if length(arg)=0 then return arg end if
    if length(arg)=0 then return "" end if
    if not integer(arg[TYPE]) then
        allargsvalid = false
--DEV (and elsewhere) - may be a lesser error for some routines/flag per??
--also, for the properties window, we should not rely on IupGetAttribute(handle[x],xxx) but attributes[x][i] instead...
--      ?{"resolve_arg",arg,"(allargsvalid:=false), errorcount+=1 line 3742"}
--      errorcount += 1
        iserr = 1
        if find(pdi[NAME],{"IupSetAttribute",
                           "IupSetInt",
--                         "IupSetAttributeId",
--                         "IupMatSetAttribute",
--                         "IupSetStrAttribute",
                           "XXIupSetAttributeHandle"}) then
            iserr = 0
        end if
        erm = iff(iserr?", errorcount +=1":"")
--      printf(1,"warning - %s unresolved (line %d) [%sline 3769]\n",{name,arg[LINE],erm})
        string sarg = sprint(arg,maxlen:=20)
        printf(1,"warning - %s unresolved (for %s)%s, [3771]\n",{sarg,pdi[NAME],erm})
        errorcount += iserr
--21/11/17:
--      return "invalid"
        return -2
    end if
    switch arg[TYPE] do
        case DQUOTE:
--DEV I think this has already been done??
            res = arg[NAME]
--          res = unquote(arg[NAME])
--          res = dequote(arg[NAME])
--?{"??? resolve_arg line 3755, res=",res,"dequote(res)=",dequote(res)}
--      case LETTER: --(10)
        case IDENT: --(10)
            name = arg[NAME]
            k = find(name,names)
            if k=0 or not integer(namedx[k]) then
--DEV we should have a constants array (initialised with NULL)
--20/11/17: [DONE, may be desired elsewhere]
--              if not find(name,{"NULL"}) then
                k = find(name,constants)
                if k=0 then
                    allargsvalid = false
--?parse_data[pid] -- pid is 0...
--?pdi
--                  ?{"resolve_arg",k,name,"(allargsvalid:=false) [errorcount +=1, line 3764]"}
--                  ?{"resolve_arg",k,name,"(allargsvalid:=false) [errorcount +=1, line 3764]",pdi[NAME]}
--                  errorcount += 1

--/"*
                    iserr = 1
                    if find(pdi[NAME],{"IupSetAttribute",
                                       "IupSetInt",
                                       "IupSetAttributeId",
                                       "IupMatSetAttribute",
                                       "IupSetStrAttribute",
                                       "IupSetAttributeHandle"}) then
                        iserr = 0
                    end if
                    erm = iff(iserr?", errorcount +=1":"")
                    printf(1,"warning - %s unresolved (line %d)%s, [3812]\n",{name,arg[LINE],erm})
                    errorcount += iserr
--*!/
--                  return "invalid"
                    return -2
                end if
--DEV clean this up... (ie initialise constvals better)
--if k=1 then
--              res = NULL
--else
                res = resolve_arg(0,constvals[k],0,0,pdi)
--end if
            else
--if k=13 then trace(1) end if
                kdx = namedx[k]
--?{"?ra?",parse_data[k]}
                res = handles[kdx]
                if res=0 then
--              if 1 then   -- creates 43 not 13 entries!!
                    handles[kdx]=-1
--                  res = create_control(k,parse_data[k],pid,aschild)
--?k
--                  res = resolve_arg(parse_data[k],pid,aschild)
                    res = resolve_arg(kdx,parse_data[kdx],pid,aschild,pdi)
--                  res = resolve_arg(parse_data[k],pid,0)  -- NO
--                  res = resolve_arg(parse_data[k],lastnode,aschild)   -- NO
                    handles[kdx] = res
                end if
--              if res=NULL then
--                  allargsvalid = false
--              end if
            end if
        case SEQ:   -- (-5)
            -- arg is {TYPE=SEQ,NAME="{",LINE,BEGIN,END,ARGS}
            --         (where LINE,BEGIN,END locate the source "{")
            res = {}
            name = arg[NAME]
            if name!="{" then ?9/0 end if
            if length(arg)!=ARGS then ?9/0 end if
            arg = arg[ARGS]
            -- arg is {[odd,{",",odd}],"}"}
            -- where "," and "}" are really {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
            --  (and odd are as per argi with and_bits(ai,1)=1 below)
            --  (actually, a trailing "," is also allowed (and no "}"), for ",$" etc.)
            if and_bits(length(arg),1) then ?9/0 end if
            for ai=1 to length(arg) do
                sequence argi = arg[ai]
--              name = argi[NAME]
                if and_bits(ai,1)=1 then
--                  aitype = argi[TYPE]
--                  if not find(aitype,{IDENT,FUNC}) then ?9/0 end if
                    if argi={} then
                        ?"??? argi={} line 3815"
                    elsif find(argi[TYPE],{IDENT,FUNC}) then
--                  if aitype=IDENT then
                        newpid = lastnode+1
--                      res &= resolve_arg(argi,pid,aschild)
                        res &= resolve_arg(0,argi,pid,ai=1,pdi)
--                      res &= resolve_arg(argi,pid,0)  -- OK (or the one above???)
--                      res &= resolve_arg(argi,newpid,aschild)
--                      res &= resolve_arg(argi,lastnode,aschild)   -- NO
                        pid = newpid
--                  elsif aitype=FUNC then
--                      -- argi is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
----                        ?9/0
--                      newpid = lastnode+1
----                        res &= create_control(0,argi,pid,aschild)
--                      res &= resolve_arg(argi,pid,aschild)
----                        res &= resolve_arg(argi,pid,0)  -- NO
----                        res &= create_control(0,argi,newpid,aschild)
----                        res &= create_control(0,argi,lastnode,aschild)
--                      pid = newpid
--                  else
--                      ?9/0
                    end if
                else
                    if argi[TYPE]!=SYMBOL then ?9/0 end if
                    -- argii is {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
                    name = argi[NAME]
                    if name!="," then
                        if ai<length(arg) then ?9/0 end if
                        if name!="}" then ?9/0 end if
                    end if
                end if
            end for
        case DIGIT:
            -- arg is {TYPE=DIGIT,tokint,LINE,BEGIN,END,ARGS}
            res = arg[2]
        case FUNC:
--          res = create_control(0,arg,pid,aschild)
            res = create_control(adx,arg,pid,aschild)
--          res = create_control(0,arg,pid,0)   --NO
--          res = create_control(0,arg,lastnode,aschild)    -- NO
        case MINUS:
            arg[2] = resolve_arg(0,arg[2],0,false,pdi)
            arg[3] = resolve_arg(0,arg[3],0,false,pdi)
--?{"MINUS",arg}
            if allargsvalid then
                res = arg[2]-arg[3]
            else
                res = -3
            end if
        default:
--          ?{"resolve_arg",arg}
            ?{"resolve_arg",arg,"(allargsvalid:=false), errorcount+=1 line 3770"}
            allargsvalid = false
            errorcount += 1
            res = -3
    end switch
--?{"<<resolve_arg",arg}
    return res
end function

-- modified version of sprint():

function allascii(string x)
-- Phix allows "strings" to hold binary data, so double check 
-- before printing it as a string.
integer c
    for i=length(x) to 1 by -1 do
        c = x[i]
        if c<' ' or c>#FF or find(c,`\"'`) then
            c = find(c,"\t\n\r\\\"\'\0")
            if c then
                x[i..i] = '\\'&`tnr\"'0`[c]
            else
                return 0
            end if
        end if
    end for
--  if withquotes then
        x = `"`&x&`"`
--  end if
    return x
end function

function hsprint(object x)
-- modified version of sprint, with special "handle substitution"
object s, xi

    if atom(x) then
        integer k = find(x,handles)
        if k then
            k = find(k,namedx)
            if k then return names[k] end if
--          if k then ?{">>>>>return name",k} end if
        end if
        s = sprintf("%.10g", x)
        if not integer(x)
        and not find('.',s)
        and not find('e',s)         -- eg 1e308
        and not find('n',s) then    -- (inf/nan)
            -- make sure you can tell 5 and 5.00000000001 
            --  apart in ex.err, trace, ?x, and the like.
            s &= ".0"
        end if
        return s
    end if
    if string(x) then
        s = allascii(x)
        if string(s) then return s end if
    end if
    s = "{"
    for i=1 to length(x) do
        xi = x[i]
        s &= hsprint(xi)
        if i<length(x) then
            s &= ','
        end if
    end for
    s &= "}"
    return s
end function

sequence RASTERSIZENULL

--SUG make pGUI.e/paramormalise global, for use here.


--procedure apply_update(Ihandle ih, integer i)
procedure apply_update(integer ih, integer i, integer hdx, integer aid)
-- aid is very specific: after say tabs=IupTabs({}), and apply_updates is called for 
--                       an IupAppend(tabs,tab), we need to make tab a child of tabs.
--                       (that stuff is only for 
    sequence pdi = parse_data[i]
    if pdi[TYPE]!=PROC then ?{"9/0p",i,"!=PROC"} end if
    if length(children[i]) then ?9/0 end if
    if length(updates[i]) then ?9/0 end if
    string procname = pdi[NAME]
--if procname="IupSetCallback" then trace(1) end if
--  integer procdx = find(procname,iupnames)
    integer procdx = find(procname,IupProcs)
    sequence args = pdi[ARGS]
    allargsvalid = true
    for k=1 to length(args) do
        integer pid = 0
        bool aschild = false
        if procname="IupAppend" and k=2 then
            aschild = true
            pid = aid
        end if
        args[k] = resolve_arg(0,args[k],pid,aschild,pdi)
        if k=2 and find(args[2],{"PARENTDIALOG","RESTORE","DETACH"}) then
            allargsvalid = false
--??is this an error??
--          ?{"PARENTDIALOG",args,"(allargsvalid:=false) [errorcount +=1, line 3658]"}
--          errorcount += 1
--no, carry on!
--          exit
        end if
    end for
--20/11/17 (for CircleDraw):
--{">>IupSetStrAttribute",{14244952,"TITLE","Adjust diameter of circle at (%d,%d)","invalidinvalid"}}
    if procname="IupSetStrAttribute"
    and not allargsvalid
    and length(args)=4
    and Ihandle(args[1])
    and string(args[2])
    and string(args[3]) then
--      ?{">>IupSetStrAttribute",args}
        args = args[1..3]
--DEV must be a better way...
        allargsvalid = true
    end if

    if procname="IupSetAttribute"
    and length(args)>=3
    and args[2]="RASTERSIZE"
    and args[3]=NULL then
        -- A very specific requirement/assumption:
        -- IupSetAttribute(ih,"RASTERSIZE",NULL) to be done after IupMap().
--      printf(1,"IupSetAttribute(%d,\"RASTERSIZE\",NULL) [deferred]\n",{ih})
--      RASTERSIZENULL = append(RASTERSIZENULL,{ih,dialogs[i]})
        RASTERSIZENULL = append(RASTERSIZENULL,{ih,dialogN[i]})
--      RASTERSIZENULL = append(RASTERSIZENULL,{ih,i})
    elsif procname="IupSetCallback" then
        -- (ignore any error)
    elsif allargsvalid then
--if procname="IupSetAttribute" then ?args end if
--?{procname,procdx,ih}
--  printf(1,"call_proc(%s[%d],%s)\n",{procname,iuprids[procdx],sprint(args)})
--  printf(1,"call_proc(%s[%d],%s)[%d]\n",{procname,iuprids[procdx],sprint(args),ih})
if SHOWCONTROLS then
--      printf(1,"call_proc(%s[%d],%s)[%d]\n",{procname,procdx,sprint(args),ih})
        printf(1,"call_proc(%s,%s) - as per line %d\n",{procname,hsprint(args),pdi[LINE]})
end if
--      call_proc(iuprids[procdx],args)
        if find(args[1],{-1,-2,-3}) then
            ?"oops, args[1] is -1/2/3, errorcount +=1, [3681]"
            errorcount += 1
        else
            call_proc(IupProcIds[procdx],args)
            if hdx!=0 then
                if procname="IupSetAttribute"
                or procname="IupSetStrAttribute"
                or procname="IupSetInt" then
                    all_properties[hdx] = append(all_properties[hdx],args[2])
                elsif procname="IupSetAttributes" then
                    sequence {names,vals} = parse_attributes(args[2])
                    all_properties[hdx] &= names
                elsif procname!="IupSetAttributeHandle"
                  and procname!="IupAppend"
                  and procname!="IupSetAttributeId" then
                    ?{"???[3892]"&procname}
                end if
            end if
        end if
    else -- (not allargsvalid)
if SHOWCONTROLS then
--      printf(1,"[not] call_proc(%s[%d],%s)[%d]\n",{procname,procdx,sprint(args),ih})
        printf(1,"[not] call_proc(%s,%s) - as per line %d [4102]\n",{procname,hsprint(args),pdi[LINE]})
end if
    end if
end procedure

--integer once = 0
--procedure create_control(integer i)
function create_control(integer i, sequence pdi, integer pid, bool aschild)
--
-- i is 0 from resolve_arg(ie nested), else from dialogs[] or children[] (an index to parse_data)
-- pdi is from arg (if nested), else parse_data[i]
-- pid is -1 for root, else passed through (do we need a separate field??)
-- aschild is
--
atom res
--integer wasnode = nextnode
bool bBranch
string aibl
integer newpid
integer newpid2 = pid
integer thisnode
integer hdx = 0
integer aid = 0
--?{"create_control",i,pdi}
    if pdi[TYPE]!=FUNC then ?9/0 end if
    string funcname = pdi[NAME]
    integer k = find(funcname,aliases)
    if k then
        funcname = alias[k]
    end if
    integer funcdx = find(funcname,iupnames)
--  if funcdx=0 or find(funcname,{"Icallback","length","get_image","sprintf","buildDummyData"}) then
    if funcdx=0 then
        if not find(funcname,{"Icallback"}) then
            allargsvalid = false
--          if once=0 then
--              ?{funcname,"(argsvalid:=false) [errorcount +=1, line 3985]"}
--              once = 1
--          end if
--          errorcount += 1
            integer iserr = 1
            if find(funcname,{"length",
                              "sprint",
                              "sprintf",
                              "IupSetAttribute",
--                            "IupSetInt",
--                            "IupMatSetAttribute",
--                            "IupSetStrAttribute",
                              "XXXIupSetAttributeHandle"}) then
                iserr = 0
            end if
            string erm = iff(iserr?", errorcount +=1":"")
            printf(1,"warning - %s unresolved (line %d)%s, [4154]\n",{funcname,pdi[LINE],erm})
            errorcount += iserr
        end if
        res = NULL
    else
        string nodename = funcname
        if upper(cem[funcdx])!='M' then
--          res = NULL
--          bBranch = (find(cem[funcdx],"CM")!=0)
            bBranch = (cem[funcdx]='C')
            integer kdx = find(i,namedx)
            if kdx then
                nodename &=" ("&names[kdx]&")"
--          elsif find(funcname,{"IupSubMenu","IupSubmenu","IupMenuItem","IupItem"})
--            and pdi[ARGS][1][TYPE]=DQUOTE then
--              nodename &=" ("&pdi[ARGS][1][NAME]&")"
            end if
            aibl = iff(aschild?"ADD":"INSERT")&iff(bBranch?"BRANCH":"LEAF")
--printf(1,"IupSetAttributeId(hierarchytree, \"%s\", %d, \"%s\")  -- [pid=%d,bBranch=%d,aschild=%d,i=%d,kdx=%d]\n",{aibl,lastnode,nodename,pid,bBranch,aschild,i,kdx})
--          IupSetAttributeId(hierarchytree, aibl, lastnode, nodename);
--          newpid = iff(kdx?pid:lastnode)
if SHOWBRANCHINFO then
--?IupGetInt(hierarchytree,"LASTADDNODE")
printf(1,"IupSetAttributeId(hierarchytree, \"%s\", %d, \"%s\")  -- [pid=%d,lastnode=%d,bBranch=%d,aschild=%d,i=%d,kdx=%d]\n",{aibl,pid,nodename, pid,lastnode,bBranch,aschild,i,kdx})
--?IupGetInt(hierarchytree,"LASTADDNODE") --DOH! printf does *NOT* update!!!
--aid = lastnode
end if
--if lastnode=2 then ?9/0 end if
--if pid=9 then ?9/0 end if
            IupSetAttributeId(hierarchytree, aibl, pid, nodename);
            aid = IupGetInt(hierarchytree,"LASTADDNODE")
--?{"aid",aid}
--          string icon = icons[funcdx]
            string icon = get_image(icons[funcdx])
            lastnode += 1
            thisnode = lastnode
            if USETREEIMAGES then
                IupSetAttributeId(hierarchytree, "IMAGE", thisnode, icon)
                if bBranch then
                    IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", thisnode, icon)
                end if
            end if
        end if -- (not menus)
--?989898
        sequence args = pdi[ARGS]
        allargsvalid = true
--?funcname
        integer childk = iff(find(funcname,{"IupSubMenu","IupSubmenu","IupMenuItem","IupItem"})?2:1)
        for k=1 to length(args) do
            newpid = lastnode
            args[k] = resolve_arg(0,args[k],newpid,k=childk,pdi)
        end for
--DEV/SUG show maybe "handles[10]/ok_btn = "?? or ok_btn(handles[10])
--      string lhs = iff(i=0?"res":sprintf("handles[%d]",{i}))
        string lhs = "res"
        if i!=0 then
            lhs = sprintf("handles[%d]",{i})
            integer ndx = find(i,namedx)
            if ndx then
                lhs = sprintf("%s(%s)",{names[ndx],lhs})
            end if
        end if
--?{"<<",funcname}
        if not allargsvalid then
            lhs = "[not]" & lhs
--          errorcount += 1 (already accounted for?)
        end if
--DEV we might want to build the dialog from the tree...
if SHOWCONTROLS then
--      printf(1,"%s = call_func(%s[%d],%s)\n",{lhs,funcname,iuprids[funcdx],sprint(args)})
        printf(1,"%s = call_func(%s,%s) -- as per line %d\n",{lhs,funcname,hsprint(args),pdi[LINE]})
end if
        res = -2    --DEV fake/temp
        if allargsvalid then
            if length(args) and (args[1]=-2 or (sequence(args[1]) and find(-2,args[1]))) then
--? what about -1, -3?
                ?"oops, -2 in args 1 [errorcount +=1, line 3802]"
                errorcount += 1 
            else
--DEV...
--  (eg) args = {"Restore me!",0,"EXPAND=YES, ACTIVE=NO"}
--sequence wasargs
--DEV can we do this on sig[funcdx]?
                if find(funcname,{"IupButton","IupToggle"})
--              if find(funcname,{"IupButton","IupToggle","IupText"})   -- maybe, didne help...
-- (but what I think might help (Booker.exw) is
--      handles[9] = call_func(IupText,{"VALUECHANGED_CB",0})
--  ==> handles[9] = call_func(IupText,{}) - which is a different thing...)
                and length(args)>=2 
                and args[2]=NULL then
-- wasargs = args
                    args[2..2] = {}
                elsif find(funcname,{"IupList","IupGLCanvas"})
                and length(args)>=1 
                and args[1]=NULL then
-- wasargs = args
                    args[1..1] = {}
                elsif funcname="IupMenu" then
                    while 1 do
                        k = find(0,args[1])
                        if k=0 then exit end if
                        ?{"oops: IupMenu, line 4234",args}
                        args[1][k..k] = {}
                    end while
                end if

                res = call_func(iuprids[funcdx],args)
                all_handles = append(all_handles,res)
                all_funcdx = append(all_funcdx,funcdx)
                hdx = length(all_handles)
                all_tags = append(all_tags,hdx)
                if upper(cem[funcdx])!='M' then
if SHOWBRANCHINFO then
--printf(1,"IupTreeSetUserId(hierarchytree, thisnode=%d, hdx=%d)  -- [pid=%d,lastnode=%d,bBranch=%d,aschild=%d,i=%d,kdx=%d]\n",{aibl,pid,nodename, pid,lastnode,bBranch,aschild,i,kdx})
printf(1,"IupTreeSetUserId(hierarchytree, thisnode=%d, hdx=%d) --[LASTADDNODE=%d]\n",{thisnode,hdx,IupGetInt(hierarchytree,"LASTADDNODE")})
end if
                    IupTreeSetUserId(hierarchytree, thisnode, hdx) 
                    nodename = sprintf("[%d] %s",{hdx,nodename})
                    IupSetAttributeId(hierarchytree,"TITLE",thisnode,nodename)
--                  printf(1,"IupTreeSetUserId(hierarchytree,%d,%d)\n",{thisnode, hdx})
                end if
--              all_properties = append(all_properties,IPROPS)
                all_properties = append(all_properties,iprops(funcdx))
                integer a1 = 1
                --ditto:
                if funcname="IupLabel" then
                    a1 = 2
                end if
                for ai=a1 to length(args) do
                    object arg = args[ai]
                    if string(arg) 
                    and find('=',arg)!=0 then
                        sequence {names,vals} = parse_attributes(arg)
                        all_properties[hdx] &= names
                    end if
                end for
--wasargs = {}
            end if
            if i!=0 then
                handles[i] = res
--20/11/17:
integer wasvalid = allargsvalid,
        waserrorcount = errorcount
                for k=1 to length(updates[i]) do
                    apply_update(res,updates[i][k],hdx,aid)
                end for
allargsvalid = wasvalid
errorcount = waserrorcount
            end if
        end if
    end if
--?{"<<create_control",i}
    return res
end function

--/*
procedure show_dialog(integer di)
    IupShow(handles[di])
    for i=1 to length(RASTERSIZENULL) do
        if sequence(RASTERSIZENULL[i])
        and RASTERSIZENULL[i][2]=di then
            Ihandle ih = RASTERSIZENULL[i][1]
--          if ih!=NULL then
            IupSetAttribute(ih,"RASTERSIZE",NULL)
            RASTERSIZENULL[i] = 0
        end if
    end for
end procedure
--RASTERSIZENULL = {}
--*/


--{} = wait_key()

Ihandln livedisplay = NULL
--Ihandle dlg

function live_key_cb(Ihandle /*ih*/, atom c)
    if    c=K_F1 then ?"F1(live)"
--  elsif c=K_ESC then IupHide(dlg) return IUP_CLOSE
    elsif c=K_ESC then return IUP_CLOSE
    end if
    return IUP_CONTINUE
end function
constant cb_live_key = Icallback("live_key_cb")

function live_close_cb()
-- prevents (accidental) closure...
    IupMessage("Ignored","To exit, press escape or close the tree/properties window instead")
    return IUP_IGNORE
end function
constant cb_live_close = Icallback("live_close_cb")

function close_cb()
    if livedisplay!=NULL then
        -- otherwise app keeps running...
        -- (and as livedisdplay cannot be closed...)
        IupHide(livedisplay)
    end if
    return IUP_CLOSE
end function
constant cb_close = Icallback("close_cb")

string default_property = ""

Ihandln p_element = NULL,
        p_new,
        p_space_only,
        p_desc = NULL,
        p_attrib_list = NULL

--DEV [SPACE] to be filled in... (requires a thorough investigation...)
constant ONSET = {"SIZE","USERSIZE","RASTERSIZE","CLIENTSIZE"},
         NOTDEF = {"MINSIZE"}

function filter_sort(sequence properties)
string space_only = IupGetAttribute(p_space_only,"VALUE")
integer k = find(space_only,{"OFF","ON","NOTDEF"})
sequence res = {}
    for i=1 to length(properties) do
        string pi = properties[i]
        if  k=1
        or (k=2 and find(pi,ONSET))
        or (k=3 and find(pi,NOTDEF)) then
            if not find(pi,res) then
                res = append(res,pi)
            end if
        end if
    end for
    res = sort(res)
    return res
end function

--DOC:
-- The leading numbers shown on elements are not meant to be particularly meaningful, other than
-- to confirm that "[7] IupFill" is not the same as "[9] IupFill". They are in fact indexes to
-- the internal table of handles, initially in the order of creation but that can change with
-- insertions/deletions and drag/drop, so typically expect 1 and 2 to be on leaf nodes and the
-- top level IupDialog to have (at least initially) the highest allocated number.

function selection_cb(Ihandle /*hierarchytree*/, integer id, status) 
--?{"selection_cb",id,status}
    if status=1 then    -- selected
        -- set properties as the tree nodes are selected:
        integer userdata = IupTreeGetUserId(hierarchytree, id) 
        if userdata=0 then
            IupMessage("Error","userdata=0 (line 4298)")
            return IUP_IGNORE
        end if
        p_element = all_handles[userdata]

--      ?{"id",id,"userdata",userdata}  -- (OK)
        if p_desc!=NULL then
--          property_id = userdata
            string title = IupGetAttributeId(hierarchytree, "TITLE", id)
--DEV/test:
if IupGetAttributePtr(p_element,"WID")=NULL then
    title &= "*** NOT MAPPED ***"
end if
--          title = sprintf("[%d] %s",{userdata,title})
            IupSetAttribute(p_desc,"TITLE",title)
            IupRedraw(p_desc)
--if userdata!=0 then
--?{all_handles[userdata],all_properties[userdata]}
----?{"all_handles[userdata],all_properties[userdata]"}
--else
--?{"selection_cb,[0],[0]"}
--end if
            sequence properties = all_properties[userdata]
--          if IupGetInt(p_space_only,"VALUE")
--?{"toggle",IupGetInt(p_space_only,"VALUE")}   -- only does 1/0
--?{"toggle",IupGetAttribute(p_space_only,"VALUE")}
            properties = filter_sort(properties)
            IupSetStrAttribute(p_attrib_list,"REMOVEITEM","ALL")
            string p1 = ""
            integer l = length(properties)
            if l!=0 then
--              p_element = all_handles[userdata]
                for i=1 to l do
                    string pi = properties[i]
                    pi &= " = "&IupGetAttribute(p_element,pi)
                    IupSetStrAttributeId(p_attrib_list,"",i,pi)
                end for
--SUG if we can find the last property, select that... [DONE]
--DOC/help:
-- Selecting a property from the list makes it the default; if that
-- property can be found when a different tree node is selected, it
-- is displayed as the selected list item, otherwise the first item
-- in the list is shown selected. However, should you then select a
-- different list item that /does/ have that property, it will once
-- again become the selected entry. This makes it easier to compare 
-- the same thing on several different elements.

--              p1 = properties[1]
--              if find(default_property,properties) then
--                  p1 = default_property
--              end if
--              IupSetAttribute(p_attrib_list,"VALUE",p1)
--              integer k = find(default_property,properties)
                integer k = max(1,find(default_property,properties))
--              if k=0 then k = 1 end if
                IupSetInt(p_attrib_list,"VALUE",k)

--              Ihandle hud = all_handles[userdata]
--              p1 = IupGetAttribute(hud,p1)
            end if
        end if
    end if
    return IUP_CONTINUE
end function
constant cb_selection = Icallback("selection_cb")

function rightclick_cb(Ihandle /*hierarchytree*/, integer id) 
    IupSetInt(hierarchytree,"VALUE",id)
    return selection_cb(hierarchytree, id, 1)
end function
constant cb_rightclick = Icallback("rightclick_cb")


function space_cb(Ihandle /*p_space_only*/, integer state)
--?{"space",state}
    integer id = IupGetInt(hierarchytree,"VALUE")
    {} = selection_cb(hierarchytree, id, 1) 
    return IUP_CONTINUE
end function
constant cb_space = Icallback("space_cb")


function list_action_cb(Ihandle /*p_attrib_list*/, atom pText, integer /*item*/, state)
    if state=1 then -- selected
        string property = peek_string(pText)
        property = property[1..match(" = ",property)-1]
        default_property = property
    end if
    return IUP_CONTINUE
end function
constant cb_list_action = Icallback("list_action_cb")

bool enable_globalmotion = true -- (false while popups showing)

Ihandln attrib_dlg = NULL,
        attrib_name,
        attrib_value,
        attrib_clear

Ihandln insert_dlg = NULL

bool error_showing = false
bool attrib_active = false
bool rmenu_active = false
bool help_showing = false

function no_popups_active()
    if attrib_active=false
    and rmenu_active=false
    and (insert_dlg=NULL or IupGetAttribute(insert_dlg,"VISIBLE")="NO")
    and (attrib_dlg=NULL or IupGetAttribute(attrib_dlg,"VISIBLE")="NO")
    and not error_showing
    and not help_showing then
        return true
    end if
    return false
end function

integer last_gm_crop = -1   -- click on/global mouse move result

procedure re_enable_globalmotion()
    if no_popups_active() then
        enable_globalmotion = true
        last_gm_crop = -1
    end if      
end procedure

function attrib_clear_cb(Ihandle /*attrib_clear*/, integer state)
    IupSetInt(attrib_value,"ACTIVE",not state)
    return IUP_DEFAULT
end function
constant cb_attrib_clear = Icallback("attrib_clear_cb")

integer attrib_id  -- the tree node when edit attributes window opened

function attrib_ok_cb(Ihandle /*attrib_ok*/)
    string name = upper(IupGetAttribute(attrib_name,"VALUE"))
    if length(name) then
        bool bClear = IupGetInt(attrib_clear,"VALUE")
        nullable_string val = iff(bClear?NULL:IupGetAttribute(attrib_value,"VALUE"))
        integer id = IupTreeGetUserId(hierarchytree, attrib_id) 
        Ihandle attrib_ih = all_handles[id]
        IupSetStrAttribute(attrib_ih,name,val)
        if not find(name,all_properties[id]) then
            all_properties[id] = append(all_properties[id],name)
        end if
        -- refresh
        {} = selection_cb(hierarchytree, attrib_id, 1) 
--IupSetAttribute(attrib_ih, "SIZE", NULL)
--IupUnmap(attrib_ih)
--IupMap(attrib_ih)
--IupSetAttribute(attrib_ih, "VISIBLE", "YES")
        IupRefresh(attrib_ih)
    end if
    IupHide(attrib_dlg)
    re_enable_globalmotion()
    return IUP_CONTINUE
end function
constant cb_attrib_ok = Icallback("attrib_ok_cb")

function attrib_escape_cb(Ihandle /*attrib_dlg*/, atom c)
    if c=K_ESC then
        IupHide(attrib_dlg)
        re_enable_globalmotion()
    end if
    return IUP_CONTINUE
end function
constant cb_attrib_escape = Icallback("attrib_escape_cb")


procedure edit_attrib(string name, string val)

    if attrib_dlg=NULL then
        Ihandle lbl1 = IupLabel("Attribute:")
        attrib_name = IupText("EXPAND=HORIZONTAL")
        Ihandle lbl2 = IupLabel("Value:")
        attrib_value = IupText("EXPAND=HORIZONTAL")
        attrib_clear = IupToggle("Clear",cb_attrib_clear)
        Ihandle attrib_ok = IupButton("Ok",cb_attrib_ok)
        Ihandle vbox = IupVbox({IupFill(),
                                IupHbox({lbl1,attrib_name},
                                        "MARGIN=5x5,NORMALIZESIZE=VERTICAL"),
                                IupFill(),
                                IupHbox({lbl2,attrib_value},
                                        "MARGIN=5x5,NORMALIZESIZE=VERTICAL"),
                                IupFill(),
                                IupHbox({attrib_clear,IupFill(),attrib_ok,IupFill()})},
                        "MARGIN=5x5")
        attrib_dlg = IupDialog(vbox,"MINSIZE=400x150,MINBOX=NO,MAXBOX=NO")
        IupSetCallback(attrib_dlg,"K_ANY",cb_attrib_escape)
        IupSetAttributeHandle(attrib_dlg,"DEFAULTENTER",attrib_ok)
        IupMap(attrib_dlg) -- (set NATURALSIZE for first use)
    end if  -- (p_edit=NULL)

    -- first save the item this attribute is for...
    attrib_id = IupGetInt(hierarchytree,"VALUE")

    string ref_title = IupGetAttributeId(hierarchytree,"TITLE",attrib_id)

--  IupSetStrAttribute(attrib_dlg,"TITLE","Attribute for "&ref_title)
    IupSetStrAttribute(attrib_dlg,"TITLE","Attribute for %s",{ref_title})
    IupSetStrAttribute(attrib_name,"VALUE",name)
    IupSetStrAttribute(attrib_value,"VALUE",val)

    Ihandle start_focus = iff(length(name)?attrib_value:attrib_name)
    IupSetAttributeHandle(attrib_dlg,"STARTFOCUS",start_focus)

    enable_globalmotion = false

    integer {x,y} = IupGetIntInt(NULL,"CURSORPOS")
    integer {rx,ry} = sq_floor_div(IupGetIntInt(attrib_dlg,"NATURALSIZE"),2)
    x = max(0,x-rx)
    y = max(0,y-ry)
    IupShowXY(attrib_dlg,x,y)
end procedure

function dblclick_cb(Ihandle /*p_attrib_list*/, integer /*item*/, atom pText)
--?{"dblclick_cb",peek_string(pText)}
    string text = peek_string(pText)
    integer k = match(" = ",text)
    edit_attrib(text[1..k-1],text[k+3..$])
    return IUP_CONTINUE
end function
constant cb_dblclick = Icallback("dblclick_cb")


function key_cb(Ihandle /*ih*/, atom c)
    if c=K_F1 then ?"F1" end if
    return iff(c=K_ESC?IUP_CLOSE:IUP_CONTINUE)
end function

function exit_cb(Ihandle /*ih*/)
--DEV talk to edix!! (move IUP_CLOSE to some later dialog??)
    return IUP_CLOSE
end function
constant cb_exit = Icallback("exit_cb")

function make_more_readable(sequence data)
--(temp?) [DOH/DEV - turns out this just recreates the original!!]
sequence res
    if data={} then
        -- known examples:
        --  p[1][1] in demo\rosetta\7guis\Converter.exw [since replaced]
        --  data[i] in demo\rosetta\7guis\CRUD.exw      [since replaced]
        -- (of course you could support subscripts, but then
        --  you'd want slices, concatenation, all the builtins,
        --  and probably user defined function calls, etc...
        --  Better/simpler to force/encourage the developer to
        --  replace an inline a&b with x=a&b and then use x.
        --  Since plade has no business modifying expressions,
        --  handling and comprehension of them should be just 
        --  enough to "not drive you nuts", and no more.)
        return "<<??? (unsupported)>>"
    end if
    object d1 = data[1]
    if sequence(d1) then
        if d1="-" and length(data)=5 then
            res = d1&join(make_more_readable(data[2]),"")
        -- "not" like above?? [with a space]
        elsif find(d1,{"=","!=","<>",">","<","<=",">=","+","-","/","*","and","or","xor"}) then
            if length(d1)>1 and d1[1]>='a' then     -- "and, "or" etc
                d1 = sprintf(" %s ",{d1})           --   need spaces
            end if
            if length(data)!=3 then ?9/0 end if
            res = join(make_more_readable(data[2]),"")&
                  d1&
                  join(make_more_readable(data[3]),"")
        elsif d1="iff" then
            res = sprintf("iff(%s?%s:%s)",make_more_readable(data[7]))
        else
            for i=1 to length(data) do
                data[i] = make_more_readable(data[i])
            end for
            res = data
        end if
    else
        if d1=FUNC then         -- 20
--          data[1] = "call_func"
--          if length(data[7]) then
--              data[7] = make_more_readable(data[7])
--          end if
            res = ""
--          sequence res = ""
            if data[8]!=0 then
--              data[8] = make_more_readable(data[8])
                if data[8][1]!=IDENT then ?9/0 end if
                res = data[8][2] & " = "
            end if
            res &= data[2]&"("
            if length(data[7]) then
--              res &= make_more_readable(data[7])
--              res = {res,join(make_more_readable(data[7]))}
                res &= join(make_more_readable(data[7]),",")
            end if
            res &= ")"
        elsif d1=PROC then      -- 21
            res = data[2]&"("
--          data[1] = "call_proc"
--          data[7] = make_more_readable(data[7])
--          res = {res,join(make_more_readable(data[7])),")"}
            res &= join(make_more_readable(data[7]),",")&")"
        elsif d1=IDENT then     -- 10
--          data[1] = "ident"
            res = data[2]
        elsif d1=DQUOTE then    -- 2
--          data[1] = "string"
--          res = "\""&substitute(data[2],"\"","\\\"")&"\""
            res = `"`&substitute(data[2],`"`,`\"`)&`"`
        elsif d1=SYMBOL then    -- 1
--          data[1] = "symbol"
            res = data[2]
        elsif d1=SEQ then       -- -5
--          data[1] = "seq"
--          data[7] = make_more_readable(data[7])
            if data[7]={} then
                res = "{}"
            else
                -- (note that parse_data SEQ contain the ","s)
                res = "{"&join(make_more_readable(data[7]),"")--&"}"
            end if
        elsif d1=DIGIT then     -- 7
            res = sprintf("%d",data[2])
        else
            ?9/0
        end if
    end if
    return res
end function

function test_cb(Ihandle /*ih*/)
--DEV (create pguide_test.exw, with mods, and run it)
--?9/0
    string filename = initialcurrentdir&"pguide_test.exw"
    integer fn = open(filename,"w")
    sequence parse_tree = make_more_readable(parse_data)
--DEV the final version will not use pp() at all...
--  pp(parse_tree,{pp_File,fn,pp_StrFmt,-2})
--  pp(parse_tree,{pp_File,fn,pp_StrFmt,-2,pp_Nest,10}) -- no..
    for i=1 to length(parse_tree) do
        printf(fn,"%s\n",{parse_tree[i]})
    end for
    close(fn)
    IupMessage("test",filename&" written")
--  IupMessage("test","not implemented")
    return IUP_CONTINUE
end function

function help_cb(Ihandle /*ih*/)
--DEV (or open phix.chm, on a specific (new) page, possibly via edix...)
    help_showing = true
    enable_globalmotion = false
    IupMessage("help","some help text")
    help_showing = false
    re_enable_globalmotion()
    return IUP_CONTINUE
end function
constant cb_help = Icallback("help_cb")


--DEV/SUG add this to pGUI?
--procedure IupSetAttributeIds(Ihandle ih, sequence names, integer id, atom_string v)
--  for i=1 to length(names) do
--      IupSetAttributeId(ih, names[i], id, v)
--  end for
--end procedure

sequence srcname
--/*
function setup_tree(bool test_only=false)
--DEV (temp)
--  IupSetAttribute(tree, "TITLE0",     "Dialogs")
if SHOWDESIRED then
?srcname
    if srcname="fill.exw" then
        if test_only then return true end if
--/*
1:{20, "IupFrame", 1,23,18,25,
2:  {{20, "IupHbox", 0,23,27,33,
    {{-5, "{", 0,23,35,35,
3:    {{20, "IupButton", 0,23,36,44, {{2, "Ok", 0,23,47,48}}, 0},
4:     {1, ",", 0,23,51,51}, {20, "IupFill", 0,23,52,58, {}, 0},
       {1, "}", 0,23,61,61}}}}, 0},
   {2, `TITLE="Left aligned"`, 0,23,65,86}},
  {10, "frame_left", 0,23,5,14}},
1[1]:frame_left, IupFrame, `TITLE="Left aligned"`
2:IupHbox
3:IupButton,"Ok"
4:IupFill
5: {20, "IupFrame", 2,26,20,27,
6:  {{20, "IupHbox", 0,26,29,35,
    {{-5, "{", 0,26,37,37,
7:    {{20, "IupFill", 0,26,38,44, {}, 0}, {1, ",", 0,26,47,47},
8:     {20, "IupButton", 0,26,48,56, {{2, "Ok", 0,26,59,60}}, 0},
9:     {1, ",", 0,26,63,63}, {20, "IupFill", 0,26,64,70, {}, 0},
       {1, "}", 0,26,73,73}}}}, 0}, {2, "TITLE=Centered", 0,26,77,90}},
  {10, "frame_center", 0,26,5,16}},
5[2]:frame_center, IupFrame, `TITLE="Centered"`
6:IupHbox
7:IupFill
8:IupButton,"Ok"
9:IupFill
10: {20, "IupFrame", 3,29,19,26,
11:  {{20, "IupHbox", 0,29,28,34,
    {{-5, "{", 0,29,36,36,
12    {{20, "IupFill", 0,29,37,43, {}, 0}, {1, ",", 0,29,46,46},
13     {20, "IupButton", 0,29,47,55, {{2, "Ok", 0,29,58,59}}, 0},
       {1, "}", 0,29,62,62}}}}, 0},
   {2, `TITLE="Right aligned"`, 0,29,66,88}},
  {10, "frame_right", 0,29,5,15}},
10[3]:frame_right, IupFrame, `TITLE="Right aligned"`
11:IupHbox
12:IupFill
13:IupButton,"Ok"
14: {20, "IupDialog", 4,32,14,22,
15:  {{20, "IupVbox", 0,32,24,30,
    {{-5, "{", 0,32,32,32,
      {{10, "frame_left", 0,32,33,42}, {1, ",", 0,32,43,43},
       {10, "frame_center", 0,32,44,55}, {1, ",", 0,32,56,56},
       {10, "frame_right", 0,32,57,67}, {1, "}", 0,32,68,68}}}}, 0}},
  {10, "dialog", 0,32,5,10}},
14[4]:dialog,IupDialog,"SIZE=120, TITLE=IupFill","K_ANY",Icallback("esc_close")
15:IupVbox
 {21, "IupSetAttributes", 5,35,55,55,
  {{10, "dialog", 0,35,22,27}, {2, "SIZE=120, TITLE=IupFill", 0,35,31,53}}},
 {21, "IupSetCallback", 6,36,59,59,
  {{10, "dialog", 0,36,20,25}, {2, "K_ANY", 0,36,29,33},
   {20, "Icallback", 0,36,37,45, {{2, "esc_close", 0,36,48,56}}, 0}}}}
==
dialogs: {4}
dialoglines: {32}
dialogN: {4,4,4,4,4,4}
dlevel: {2,2,2,1,1,1}
names: {"frame_left","frame_center","frame_right","dialog"}
namedx: {1,2,3,4}
children: {{},{},{},{1,2,3},{},{}}
updates: {{},{},{},{5,6},{},{}}
cud: cccduu
fill.exw
---*** WE NEED TO STORE THESE HANDLES SOMEWHERE!!! *** (and I vote within parse_data!)
res = call_func(IupButton,{"Ok"})
res = call_func(IupFill,{})
res = call_func(IupHbox,{{15220008,15225200}})
handles[1] = call_func(IupFrame,{15225376,"TITLE=\"Left aligned\""})
res = call_func(IupFill,{})
res = call_func(IupButton,{"Ok"})
res = call_func(IupFill,{})
res = call_func(IupHbox,{{15222912,15224848,15223440}})
handles[2] = call_func(IupFrame,{15224760,"TITLE=Centered"})
res = call_func(IupFill,{})
res = call_func(IupButton,{"Ok"})
res = call_func(IupHbox,{{15222824,15224144}})
handles[3] = call_func(IupFrame,{15223264,"TITLE=\"Right aligned\""})
res = call_func(IupVbox,{{15224672,15224232,15223176}})
handles[4] = call_func(IupDialog,{15223704})
call_proc(IupSetAttributes,{15223880,"SIZE=120, TITLE=IupFill"})
call_proc(IupSetCallback,{15223880,"K_ANY",0})
handles: {15224672,15224232,15223176,15223880,0,0}
--*/
        return true
    elsif srcname="filedump.exw" then
        if test_only then return true end if
--      tab = IupHbox({IupFill()})
--      IupAppend(tabs,tab)
--  Ihandle buttons = IupHbox({IupFill(),IupButton("close",cb_exit)},"CMARGIN=13x3")
--  maindlg = IupDialog(IupVbox({tabs,
--                               matrix,
--                               buttons}),
--                      "TITLE=filedump, SHRINK=YES")
--try2:
IupSetAttributeId(hierarchytreE, "INSERTBRANCH", -1, "IupDialog (maindlg)")  -- [pid=-1,lastnode=-1,bBranch=1,aschild=0,i=76,kdx=29]
IupSetAttributeId(hierarchytreE, "ADDBRANCH", 0, "IupVbox")  -- [pid=0,lastnode=0,bBranch=1,aschild=1,i=0,kdx=0]
IupSetAttributeId(hierarchytreE, "ADDBRANCH", 1, "IupTabs (tabs)")  -- [pid=1,lastnode=1,bBranch=1,aschild=1,i=56,kdx=26]
--IupSetAttributeId(hierarchytreE, "ADDBRANCH", 0, "IupHbox (tab)")  -- [pid=0,lastnode=2,bBranch=1,aschild=1,i=14,kdx=7]
IupSetAttributeId(hierarchytreE, "ADDBRANCH", 2, "IupHbox (tab)")  -- [pid=0,lastnode=2,bBranch=1,aschild=1,i=14,kdx=7]
IupSetAttributeId(hierarchytreE, "ADDLEAF", 3, "IupFill")  -- [pid=3,lastnode=3,bBranch=0,aschild=1,i=0,kdx=0]
IupSetAttributeId(hierarchytreE, "INSERTLEAF", 2, "IupMatrix (matrix)")  -- [pid=2,lastnode=4,bBranch=0,aschild=0,i=58,kdx=27]
IupSetAttributeId(hierarchytreE, "INSERTBRANCH", 5, "IupHbox (buttons)")  -- [pid=5,lastnode=5,bBranch=1,aschild=0,i=75,kdx=28]
IupSetAttributeId(hierarchytreE, "ADDLEAF", 6, "IupFill")  -- [pid=6,lastnode=6,bBranch=0,aschild=1,i=0,kdx=0]
IupSetAttributeId(hierarchytreE, "INSERTLEAF", 7, "IupButton")  -- [pid=7,lastnode=7,bBranch=0,aschild=0,i=0,kdx=0]

--/* try1:
IupSetAttributeId(hierarchytreE, "INSERTBRANCH", -1, "IupDialog (maindlg)")  -- [pid=-1,lastnode=-1,bBranch=1,aschild=0,i=76,kdx=29]
IupSetAttributeId(hierarchytreE, "ADDBRANCH", 0, "IupVbox")  -- [pid=0,lastnode=0,bBranch=1,aschild=1,i=0,kdx=0]
IupSetAttributeId(hierarchytreE, "ADDBRANCH", 1, "IupTabs (tabs)")  -- [pid=1,lastnode=1,bBranch=1,aschild=1,i=56,kdx=26]
--IupSetAttributeId(hierarchytree, "INSERTBRANCH", 0, "IupHbox (tab)")  -- [pid=0,lastnode=2,bBranch=1,aschild=0,i=14,kdx=7]
--IupSetAttributeId(hierarchytreE, "INSERTBRANCH", 2, "IupHbox (tab)")  -- [pid=0,lastnode=2,bBranch=1,aschild=0,i=14,kdx=7]
IupSetAttributeId(hierarchytreE, "ADDBRANCH", 2, "IupHbox (tab)")  -- [pid=0,lastnode=2,bBranch=1,aschild=0,i=14,kdx=7]
IupSetAttributeId(hierarchytreE, "ADDLEAF", 3, "IupFill")  -- [pid=3,lastnode=3,bBranch=0,aschild=1,i=0,kdx=0]
IupSetAttributeId(hierarchytreE, "INSERTLEAF", 2, "IupMatrix (matrix)")  -- [pid=2,lastnode=4,bBranch=0,aschild=0,i=58,kdx=27]
IupSetAttributeId(hierarchytreE, "INSERTBRANCH", 5, "IupHbox (buttons)")  -- [pid=5,lastnode=5,bBranch=1,aschild=0,i=75,kdx=28]
--IupSetAttributeId(hierarchytreE, "INSERTBRANCH",3, "IupHbox (buttons)")  -- [pid=5,lastnode=5,bBranch=1,aschild=0,i=75,kdx=28]
IupSetAttributeId(hierarchytreE, "ADDLEAF", 6, "IupFill")  -- [pid=6,lastnode=6,bBranch=0,aschild=1,i=0,kdx=0]
IupSetAttributeId(hierarchytreE, "INSERTLEAF", 7, "IupButton")  -- [pid=7,lastnode=7,bBranch=0,aschild=0,i=0,kdx=0]
--*/

        return true
    end if

end if
    return false
end function
--*/

--function valuechanged_cb(Ihandle ih)
--  printf(1,"VALUECHANGED_CB(%s)=%s\n",{IupGetClassName(ih), IupGetAttribute(ih, "VALUE")});
--  return IUP_DEFAULT;
--end function

--function esc_close(Ihandle /*ih*/, atom c)
---- (I like all my demos to close when escape is keyed)
--  return iff(c=K_ESC?IUP_CLOSE:IUP_CONTINUE)
--end function

--function motion_cb(Ihandle /*ih*/, integer x, y, atom pStatus)
--  ?{"motion_cb",x,y,peek_string(pStatus)}
--  return IUP_CONTINUE 
--end function

Ihandle main_dlg
Ihandln wsdlg=NULL
Ihandln samp_dlg = NULL
Ihandle info, ok_btn, new_btn

--bool imlanyway = false

procedure make_live(integer dx)
--?{"make_live",dx}
    IupSetAttributeId(hierarchytree, "DELNODE", 0, "ALL")
    IupSetStrAttribute(main_dlg, "TITLE", "plade - Phix Layout Designer (%s)",{srcname})
    if dx!=0 then
        lastbranch = -1
        lastnode = -1
        integer di = dialogs[dx]
        handles[di] = -1
        handles[di] = create_control(di,parse_data[di],lastbranch,false)
        puts(1,"handles: ") ?handles
        puts(1,"all_handles: ") ?all_handles

        if errorcount!=0 then
            IupMessage("oops","%d error%s detected",{errorcount,iff(errorcount=1?"":"s")})
            errorcount = 0
        end if
--      if errorcount=0 then
            if Ihandle(handles[di]) then
                livedisplay = handles[di]
            end if
--      end if
    else
        -- new window
        livedisplay = IupDialog(NULL,"SIZE=200x100")
        all_handles = append(all_handles,livedisplay)
        integer hdx = length(all_handles)
        all_tags = append(all_tags,hdx)
--[DEV/SUG] constant K_Dialog?
        integer funcdx = find("IupDialog",iupnames)
        all_funcdx = append(all_funcdx,funcdx)
--      all_properties = append(all_properties,IPROPS)
        all_properties = append(all_properties,iprops(funcdx))
        all_properties[hdx] = append(all_properties[hdx],"TITLE")
        IupSetStrAttributeId(hierarchytree, "INSERTBRANCH", -1, "[%d] IupDialog()",{hdx})
if USETREEIMAGES then
        string icon = get_image(icons[funcdx])
        IupSetAttributeId(hierarchytree, "IMAGE", 0, icon)
        IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", 0, icon)
end if
        IupTreeSetUserId(hierarchytree, 0, hdx)
--erm...
--      handles = {livedisplay}
    end if
    if livedisplay!=NULL then
        -- prevent (accidental) closure:
        IupSetAttributes(livedisplay, "MINBOX=NO, MAXBOX=NO");
        IupSetCallback(livedisplay, "CLOSE_CB", cb_live_close);
        IupSetCallback(livedisplay, "K_ANY", cb_live_key);
--test: (BUST)
--      IupSetCallback(livedisplay, "MOTION_CB", Icallback("motion_cb"))
--      IupSetCallback(livedisplay, "ENTERWINDOW_CB", Icallback("enterwindow_cb"))
--  ?{livedisplay,"TITLE",IupGetAttribute(livedisplay,"TITLE")}
        IupShow(livedisplay)
--{} = wait_key()
        if wsdlg!=NULL then
            IupHide(wsdlg)
        end if
        if samp_dlg!=NULL then
            IupHide(samp_dlg)
        end if

--  if livedisplay!=NULL then
        IupShowXY(main_dlg,IUP_LEFT,IUP_TOP)
--      IupSetFocus(main_dlg)
--      IupSetFocus(hierarchytree)
--      IupPopup(main_dlg,IUP_CURRENT,IUP_CURRENT)
        -- start with the dialog selected:
        {} = selection_cb(hierarchytree, 0, 1) 
--      if IupMainLoopLevel()=0 then
--      if IupMainLoopLevel()=0 or imlanyway then
--          IupMainLoop()
--      end if
--  end if

    else
        IupMessage("oops","%d errors detected [livedisplay=NULL]",{errorcount})
    end if
end procedure

Ihandln window_list = NULL

function ok_cb(Ihandle /*ok_btn*/)
    make_live(IupGetInt(window_list,"VALUE"))
--  return IUP_CLOSE
    return IUP_CONTINUE
end function

function new_cb(Ihandle /*new_btn*/)
    make_live(0) -- new window
--  return IUP_CLOSE
    return IUP_CONTINUE
end function

function get_title(sequence args, string title)
    for i=1 to length(args) do
        if args[i][TYPE]=DQUOTE then
--already done??
--          string txt = dequote(args[i][NAME])
            string txt = args[i][NAME]
--?{"??? get_title line 4650, txt=",txt,", dequote(txt)=",dequote(txt)}
            sequence {names,vals} = parse_attributes(txt)
            integer k = find("TITLE",names)
            if k then
                if length(title) then
                    title &= ", "
                end if
                title &= vals[k]
            end if
        end if
    end for
    return title
end function

procedure window_selection(bool from_sample)
integer d
sequence pdd, ud, args
string title

    if window_list=NULL then
        window_list = IupList("DROPDOWN=YES, EXPAND=HORIZONTAL")
        info = IupLabel()
        ok_btn = IupButton("OK", Icallback("ok_cb"), "PADDING=5x5")
        new_btn = IupButton("New Window", Icallback("new_cb"), "PADDING=5x5")
        Ihandle vboxws = IupVbox({window_list,
                                  IupFill(),
                                  IupHbox({IupFill(),info,IupFill()}),
                                  IupFill(),
                                  IupHbox({IupFill(),ok_btn,IupFill(),new_btn,IupFill()})},
                                 "MARGIN=5x5")

        wsdlg = IupDialog(vboxws,"MINSIZE=300x140")
        IupSetAttribute(wsdlg,"TITLE","Window to amend")
        IupSetAttributeHandle(wsdlg,"PARENTDIALOG",main_dlg)
    else
        IupSetAttribute(window_list,"1",NULL)   -- clear list
    end if

    -- populate window_list, with 'IupDialog("title")' entries:
    for dx=1 to length(dialogs) do
        d = dialogs[dx]
        pdd = parse_data[d]
        if pdd[TYPE]!=FUNC then ?9/0 end if
        if pdd[NAME]!="IupDialog" then ?9/0 end if
        title = ""
        title = get_title(pdd[ARGS],title)
        ud = updates[d]
        for ux=1 to length(ud) do
            d = ud[ux]
            pdd = parse_data[d]
            if pdd[TYPE]!=PROC then ?9/0 end if
            string pname = pdd[NAME]
            if pname="IupSetAttributes" then
                title = get_title(pdd[ARGS],title)
            elsif pname="IupSetStrAttribute"
               or pname="IupStoreAttribute"
               or pname="IupSetAttribute" then
                args = pdd[ARGS]
                if args[1][TYPE]!=IDENT then ?9/0 end if
--              if args[1][NAME]!=?? then ?9/0 end if
--  pdd[1..6] = {21,"IupStoreAttribute",10,108'l',45'-',45'-'}
--  pdd[7] = {{10,"hDialog",0,108'l',19,25},{2,"TITLE",0,108'l',29,33'!'},{2,"Rot 13",0,108'l',38'&',43'+'}}
                if args[2][TYPE]=DQUOTE
                and args[2][NAME]="TITLE"
                and args[3][TYPE]=DQUOTE then
                    if length(title) then
                        title &= ", "
                    end if
                    title &= args[3][NAME]
--elsif args[2][TYPE]!=DQUOTE
--   or not find(args[2][NAME],{"SIZE","TOOLFONT"}) then
----   or args[3][TYPE]!=DQUOTE then
--?{"erm...[6056]","d",d}
--?pdd
                end if
            elsif pname!="IupSetAttributeHandle"
              and pname!="IupSetCallback"
              and pname!="IupSetInt" then
                ?9/0
            end if
        end for
        title = sprintf(`IupDialog("%s")`,{title})
        integer k = find(dialogs[dx],namedx)
        if k then
            title &= " ("&names[k]&")"
        end if
        IupSetStrAttributeId(window_list,"",dx,title)
--DEV/SUG: When integrated with Edix, let that keep a default window per source (per session is fine),
--         which should make it much slicker/less painful to flip between source & layout editing.
        if dx=1 then IupSetInt(window_list,"VALUE",1) end if
    end for

    IupSetStrAttribute(info,"TITLE","%d window%s found",{length(dialogs),iff(length(dialogs)=1?"":"s")})

    Ihandle start_focus = ok_btn,
            default_enter = ok_btn
--      IupSetAttribute(window_list,"ACTIVE","NO")
--      IupSetAttributes(ok_btn,"ACTIVE","NO")
    IupSetInt({window_list,ok_btn},"ACTIVE",length(dialogs)>0)
    IupSetInt(new_btn,"ACTIVE",not from_sample)

    if length(dialogs)=0 then
--      IupSetAttribute(window_list,"ACTIVE","NO")
--      IupSetAttribute(ok_btn,"ACTIVE","NO")
        start_focus = new_btn
        default_enter = new_btn
    elsif length(dialogs)>1 then
        start_focus = window_list
    end if

    IupSetAttributeHandle(wsdlg,"DEFAULTENTER",default_enter)
    IupSetAttributeHandle(wsdlg,"STARTFOCUS",start_focus)

--  IupSetCallback(wsdlg, "K_ANY", Icallback("esc_close"))
    IupCloseOnEscape(wsdlg)

    IupSetAttribute(wsdlg,"SIZE",NULL)
    IupRefresh(wsdlg)
    IupShow(wsdlg)

    if samp_dlg!=NULL then
        IupHide(samp_dlg)
    end if

--  if livedisplay=NULL then
--imlanyway = true
--      IupMainLoop()
--imlanyway = false
--  else
--      livedisplay = NULL
--  end if

--DEV IupHide??
--  IupHide(wsdlg)      -- too late anyway... (first time in)
--  wsdlg = IupDestroy(wsdlg)
--  window_list = NULL

end procedure

Ihandle insert_txt,
        insert_drop,
        insert_ref,
        insert_titleh,
        insert_title,
        insert_ok_btn,
        insert_cancel_btn

bool bTitle

procedure hide_insert()
    IupHide(insert_dlg)
    re_enable_globalmotion()
end procedure

constant add_mode_descs = {"child","sibling","parent"}
sequence add_modes
enum CHILD,SIBLING,PARENT

function insert_escape_cb(Ihandle /*insert_dlg*/, atom c)
    if c=K_ESC then
        hide_insert()
    end if
    return IUP_CONTINUE
end function
constant cb_insert_escape = Icallback("insert_escape_cb")

function insert_close_cb(Ihandle /*insert_dlg*/)
    hide_insert()
    return IUP_IGNORE
end function
constant cb_insert_close = Icallback("insert_close_cb")

integer insert_id       -- an idx to iupnames[] etc

function insert_ok_cb(Ihandle /*ok_btn*/)

    integer option = add_modes[IupGetInt(insert_drop,"VALUE")]
    integer pid = IupGetInt(hierarchytree,"VALUE")
--  integer childcount = IupGetIntId(hierarchytree,"CHILDCOUNT",pid)
    Ihandle insert_ih = call_func(iuprids[insert_id],{})
    if bTitle then
        string title = IupGetAttribute(insert_title,"VALUE")
        IupSetStrAttribute(insert_ih,"TITLE",title)
    end if
    all_handles = append(all_handles,insert_ih)
    all_funcdx = append(all_funcdx,insert_id)
--  all_properties = append(all_properties,IPROPS)
    all_properties = append(all_properties,iprops(insert_id))
    integer hdx = length(all_handles)
    integer uid = IupTreeGetUserId(hierarchytree, pid)
    all_tags[uid+1..uid] = {hdx} -- (insert 1 element)
--/*
-- or, maybe:
    all_tags &= hdx
    sort_tags()
--*/
    string nodename = sprintf("[%d] %s",{hdx,iupnames[insert_id]})
    bool bBranch = (find(cem[insert_id],"CM")!=0)
    string aibl, bl = iff(bBranch?"BRANCH":"LEAF")
--  Ihandle refh = all_handles[pid]
    Ihandle refh = all_handles[uid]
    integer {x,y} = IupGetIntInt(livedisplay,"SCREENPOSITION")
--  IupUnmap(livedisplay)
    integer thisnode

    if option=PARENT then
        if bBranch=false then ?9/0 end if
        Ihandle ph = IupGetParent(refh)
--DANG fails for single-child containers...
--IupUnmap/IupDetach...
--Simplification 1: Let IupSplit, being the only 2-child case, sometimes get it wrong...
--or: integer count = IupGetChildCount(Ihandle ih) 
-- integer pos = IupGetChildPos(Ihandle ih, Ihandle child) (returns 0/1, -1 if not found)
        integer k = find(ph,all_handles)
        if max_children[all_funcdx[k]]>0 then
--not sure this helps one jot...
            IupSaveClassAttributes(refh)
            IupDetach(refh)
            IupInsert(ph,NULL,insert_ih)
            IupMap(insert_ih)
--          IupInsert(insert_ih,NULL,refh)
            IupAppend(insert_ih,refh)
            IupMap(refh)
        else
            IupInsert(ph,refh,insert_ih)
            IupMap(insert_ih)
            if IupReparent(refh, insert_ih, NULL)!=IUP_NOERROR then
                IupMessage("oops","reparent fairure")
            end if
        end if
--      IupMap(ih)
        IupSetAttributeId(hierarchytree, "INSERTBRANCH", pid, nodename)
        thisnode = IupGetInt(hierarchytree,"LASTADDNODE")
        -- bit messy but it works:
        IupSetAttributeId(hierarchytree, "ADDLEAF", thisnode, "TEMP")
        IupSetIntId(hierarchytree, "MOVENODE", pid, thisnode+1)
        IupSetAttributeId(hierarchytree, "DELNODE", pid+1, "SELECTED")
        thisnode = pid
    else
        if option=CHILD then
--DEV IupExpander needs IupAppend... (some others might too)
            if all_funcdx[uid]=K_IupExpander then
                IupAppend(refh,insert_ih)
            else
                IupInsert(refh,NULL,insert_ih)
            end if
            aibl = "ADD"&bl
        elsif option=SIBLING then
            Ihandle insert_ph = IupGetParent(refh)
            Ihandln insert_next = IupGetNextChild(insert_ph,refh)
            if insert_next=NULL then
                IupAppend(insert_ph,insert_ih)
            else
                IupInsert(insert_ph,insert_next,insert_ih)
            end if
            aibl = "INSERT"&bl
        else
            ?9/0    -- unknown option
        end if
        IupMap(insert_ih)
        IupSetAttributeId(hierarchytree, aibl, pid, nodename)
        thisnode = IupGetInt(hierarchytree,"LASTADDNODE")
        if bBranch then
            -- add then immediately remove a child, to force expanded status:
            IupSetAttributeId(hierarchytree, "ADDLEAF", thisnode, "TEMP")
            IupSetAttributeId(hierarchytree, "DELNODE", thisnode+1, "SELECTED")
        end if
    end if

--?{"thisnode",thisnode}
    IupTreeSetUserId(hierarchytree, thisnode, hdx)
  if USETREEIMAGES then
    string icon = get_image(icons[insert_id])
    IupSetAttributeId(hierarchytree, "IMAGE", thisnode, icon)
    if bBranch then
        IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", thisnode, icon)
    end if
  end if
    IupSetAttribute(livedisplay,"SIZE",NULL)
    IupRefresh(livedisplay)
--no help??
--  IupSaveClassAttributes(livedisplay) 
--/!*
--  IupMap(livedisplay)
--  IupShowXY(livedisplay,x,y)
--*!/

--/*
    aibl = iff(aschild?"ADD":"INSERT")&iff(bBranch?"BRANCH":"LEAF")

    IupSetAttributeId(hierarchytree, aibl, pid, nodename);

    IupSetAttributeId(hierarchytree, "IMAGE", thisnode, icon)
    if bBranch then
        IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", thisnode, icon)
    end if

    string nodename = funcname
    nodename = sprintf("[%d] %s",{hdx,nodename})
    IupSetAttributeId(hierarchytree,"TITLE",thisnode,nodename)

    error = IupReparent(drag_elem, drop_elem, ref_child)

    IupTreeSetUserId(hierarchytree, thisnode, hdx) 
--*/
    hide_insert()
    return IUP_CONTINUE
end function
constant cb_insert_ok = Icallback("insert_ok_cb")

function cancel_cb(Ihandle /*ok_btn*/)
    hide_insert()
    return IUP_CONTINUE
end function
constant cb_cancel = Icallback("cancel_cb")

     
procedure set_add_modes(integer id, integer pid, integer children, integer tid, integer grandkids)
--
--  set add_modes as valid for adding id as child/sibling/parent of tid, where tid's parent is pid
--
--  id, pid, and tid are indexes to iupnames[] etc.
--  id is the element type being added (as selected from the pop-up menu)
--  pid is the type of the parent of the target node (0 if tid==K_Dialog)
--  tid is the type of the target node (as right-clicked on)
--  children is the already existing count on puid.
--   (ie whereby we got pid from all_funcdx[puid])
--  grandkids is the already existing count on tuid
--   (ie whereby we got tid from all_funcdx[tuid])
--
-- Technical note: this has been written without using (existing) Ihandles, and forcing the caller to
--  invoke IupGetParent and IupGetChildCount, etc, so that it can be fully unit tested, and in fact 
--  this whole routine was originally factored out solely for unit testing/tdd purposes.
--
    
    if id=K_IupDialog then
        add_modes = {}
    elsif tid=K_IupDialog then
        if grandkids=0 then
            add_modes = {CHILD}
        else
            add_modes = {}
        end if
    else
        integer mci = max_children[tid]
        switch mci do
            case 0:     add_modes = {SIBLING}
            case 1:     add_modes = iff(grandkids=1?{SIBLING}:{CHILD,SIBLING})
            case 2:     add_modes = iff(grandkids=2?{SIBLING}:{CHILD,SIBLING})
            case -1:    add_modes = {CHILD,SIBLING}
            else ?9/0
        end switch
    end if

    if tid!=K_IupDialog then
        if max_children[pid]=children then
            integer k = find(SIBLING,add_modes)
            if k then
                add_modes[k..k] = {}
            end if
        end if
    end if

    if max_children[tid]=grandkids then
        integer k = find(CHILD,add_modes)
        if k then
            add_modes[k..k] = {}
        end if
    end if

--  sig = clean_sig(id)


--XXX (menus gone)
    -- Aside: it is IupMenu->IupSubMenu->IupMenu, ie you cannot have an IupMenu as 
    --  a (direct) child of an IupMenu, and an IupSubMenu can only take an IupMenu
    --  as a child. Therefore PARENT (ie squidge id between pid and tid) is never 
    --  valid in any menu-related cases, ever. Drag and drop is available instead.

    if id!=K_IupDialog
    and tid!=K_IupDialog
--  and not find(cem[tid],"mM")
--  and not find(cem[id],"mM")
--  and not find(sig,{"","[T]","[O]","[TT]"}) then              -- no children
    and max_children[id]!=0 then
--wrong place! (it is sibling we must attack!)
--      if max_children[pid]=-1
--      or max_children[pid]<children then
            add_modes &= PARENT
--      end if
    end if
end procedure

procedure unit_tests()
-- (feel free to add more)
integer pid
    for id=1 to length(iupnames) do
        string idname = iupnames[id]    -- (for diagnostics only)
        bool bMenu = (upper(cem[id])='M')
        if not bMenu then
            bool bElement = (upper(cem[id])='E')
            --
            -- 1) An IupDialog cannot have any siblings, or >1 child.
            --
            set_add_modes(id,0,0,K_IupDialog,0)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            else
                if add_modes!={CHILD} then ?9/0 end if
            end if
            set_add_modes(id,0,0,K_IupDialog,1)
            if add_modes!={} then ?9/0 end if
            --
            -- 2) Nothing can take an IupDialog as a child or sibling.
            --
            set_add_modes(K_IupDialog,K_IupVbox,1,id,0)
            if add_modes!={} then ?9/0 end if
            --
            -- 3) The following containers take precisely one child:
            --
            sequence onechild = {"IupBackgroundBox","IupDetachBox","IupDialog",
                                 "IupExpander","IupFrame","IupRadio","IupSbox",
                                 "IupScrollBox","IupSpinBox"}
            for oc=1 to length(onechild) do
                pid = find(onechild[oc],iupnames)
                set_add_modes(id,K_IupVbox,1,pid,0)
                if pid=K_IupDialog then
                    if id=K_IupDialog then
                        if add_modes!={} then ?9/0 end if
                    else
                        if add_modes!={CHILD} then ?9/0 end if
                    end if
                elsif id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={CHILD,SIBLING} then ?9/0 end if
                else
                    if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
                end if
                set_add_modes(id,K_IupVbox,1,pid,1)
                if pid=K_IupDialog
                or id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={SIBLING} then ?9/0 end if
                else
                    if add_modes!={SIBLING,PARENT} then ?9/0 end if
                end if
            end for
            --
            -- 4) IupSplit takes precisely two children
            --      (the only container that does)
            --
            pid = find("IupSplit",iupnames)
            set_add_modes(id,K_IupVbox,1,pid,0)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            elsif bElement then
                if add_modes!={CHILD,SIBLING} then ?9/0 end if
            else
                if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
            end if
            set_add_modes(id,K_IupVbox,1,pid,1)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            elsif bElement then
                if add_modes!={CHILD,SIBLING} then ?9/0 end if
            else
                if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
            end if
            set_add_modes(id,K_IupVbox,1,pid,2)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            elsif bElement then
                if add_modes!={SIBLING} then ?9/0 end if
            else
                if add_modes!={SIBLING,PARENT} then ?9/0 end if
            end if
            --
            -- 5) The following containers take any number of children: ("[P]")
            --
            sequence anychild = {"IupCbox","IupGridBox","IupHbox",
                                 "IupTabs","IupVbox","IupZbox"}
            for ac=1 to length(anychild) do
                pid = find(anychild[ac],iupnames)
                set_add_modes(id,K_IupVbox,1,pid,5)
                if id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={CHILD,SIBLING} then ?9/0 end if
                else
                    if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
                end if
            end for
            --
            -- 6) The following are not containers/take no children:
            --
            sequence nochild = {"IupButton","IupFlatButton","IupCalendar",
--                              "IupDatePick","IupCanvas","IupGLCanvas","IupCells",
                                "IupDatePick","IupCanvas","IupCells",
--                              "IupDial",  -- (removed in 3.24)
                                "IupFill","IupLabel","IupLink",
                                "IupList","IupMatrix","IupMenuItem",
                                "IupSeparator","IupProgressBar","IupPlot",
                                "IupToggle","IupText","IupTree",
                                "IupMultiLine","IupValuator"}
            for nc=1 to length(nochild) do
                pid = find(nochild[nc],iupnames)
                set_add_modes(id,K_IupVbox,1,pid,0)
                if id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={SIBLING} then ?9/0 end if
                else
                    if add_modes!={SIBLING,PARENT} then ?9/0 end if
                end if
            end for
        end if
    end for
end procedure
unit_tests()

function get_childcount(integer pid, uid)
    integer children = IupGetIntId(hierarchytree, "CHILDCOUNT", pid)
    integer childcount = IupGetChildCount(all_handles[uid])
    if iupnames[all_funcdx[uid]]="IupDetachBox" then
--DEV tryme:
--  if all_funcdx[uid]=K_IupDetachBox then
        childcount -= 1 -- hidden IupCanvas for the bar handler
    end if
--  if children!=childcount then ?9/0 end if -- sanity check
    if children!=childcount then ?{"9/0 line 5064 (childcount)",children,childcount} end if -- sanity check
    return children
end function

function insert_action_cb(Ihandle /*insert_drop*/, atom /*pText*/, integer /*item*/, /*state*/)
    integer item = IupGetInt(insert_drop,"VALUE")
    IupSetInt(insert_ok_btn,"ACTIVE",item!=0)
    return IUP_CONTINUE
end function
constant cb_insert_action = Icallback("insert_action_cb")

procedure confirm_insert(integer id)
Ihandle vboxci

    if insert_dlg=NULL then

        insert_txt = IupLabel() -- "Insert a new ..."
        insert_drop = IupList(cb_insert_action,"DROPDOWN=YES")
        insert_ref = IupLabel() -- "of ..."

        insert_title = IupText("EXPAND=HORIZONTAL")
        -- (the following is visible only on those that deserve it)
        insert_titleh = IupHbox({IupLabel("TITLE "),insert_title},"ALIGNMENT=ACENTER")

        insert_ok_btn = IupButton("OK", cb_insert_ok, "PADDING=5x5")
        insert_cancel_btn = IupButton("Cancel", cb_cancel, "PADDING=5x5")

        vboxci = IupVbox({IupHbox({IupFill(),insert_txt,insert_drop,insert_ref,IupFill()},
                                  "MARGIN=5x5,NORMALIZESIZE=VERTICAL"),
                          IupFill(),
                          insert_titleh,
                          IupFill(),
                          IupHbox({IupFill(),insert_ok_btn,IupFill(),insert_cancel_btn,IupFill()})},
                         "MARGIN=5x5")

        insert_dlg = IupDialog(vboxci,"MINSIZE=300x140,MINBOX=NO,MAXBOX=NO")
        IupSetAttribute(insert_dlg,"TITLE","Confirm insert")

--      IupSetCallback(insert_dlg, "K_ANY", Icallback("esc_close"))     -- NO!
        IupSetCallback(insert_dlg, "K_ANY", cb_insert_escape)
--      IupCloseOnEscape(insert_dlg)    -- NO!
        IupSetCallback(insert_dlg, "CLOSE_CB", cb_insert_close);
    end if -- (insert_dlg=NULL)

    insert_id = id
    IupSetStrAttribute(insert_txt,"TITLE","Insert a new %s as ",{iupnames[id]})
    integer pid = IupGetInt(hierarchytree,"VALUE")
    integer uid = IupTreeGetUserId(hierarchytree, pid)
--?{"confirm_insert: {pid,uid}=",{pid,uid}}
--  if pid=-1 or uid<1 or uid>length(all_handles) then
----    ?{"confirm_insert - oops: {pid,uid}=",{pid,uid}}
--      IupMessage("oops",sprintf("confirm_insert - {pid,uid} is {%d,%d}",{pid,uid}))
--      return
--  end if
    string ref_title = IupGetAttributeId(hierarchytree,"TITLE",pid)
--  integer cemi = cem[id]

    IupSetStrAttribute(insert_ref,"TITLE"," of %s",{ref_title})
    
    integer children = get_childcount(pid,uid)
--DEV above pid should prolly be tid?
    integer p_id, siblings
if all_funcdx[uid]=K_IupDialog then
    p_id = 0
    siblings = 0
else
    Ihandle parent = IupGetParent(all_handles[uid])
    p_id = find(parent,all_handles)
--  if p_id = 0 then ?9/0 end if
    p_id = all_funcdx[p_id]
    siblings = IupGetChildCount(parent)
end if
    set_add_modes(id,p_id,siblings,all_funcdx[uid],children)
--?{"id",id,"p_id",p_id,"siblings",siblings,"fdx",all_funcdx[uid],"children",children,"add_modes",add_modes}

    Ihandle default_enter = insert_ok_btn,
            start_focus = insert_ok_btn
    IupSetAttribute(insert_drop,"REMOVEITEM","ALL")
    for i=1 to length(add_modes) do
        IupSetAttributeId(insert_drop,"",i,add_mode_descs[add_modes[i]])
    end for
    if length(add_modes)=0 then
?"does this ever happen??" -- (the error_showing message should occur instead)
        IupSetInt(insert_drop,"ACTIVE",false)
        IupSetInt(insert_ok_btn,"ACTIVE",false)
        default_enter = insert_cancel_btn
        start_focus = insert_cancel_btn
    elsif length(add_modes)=1 then
        IupSetInt(insert_drop,"ACTIVE",false)
        IupSetInt(insert_ok_btn,"ACTIVE",true)
        IupSetInt(insert_drop,"VALUE",1)
    else
        IupSetInt(insert_drop,"ACTIVE",true)
        IupSetInt(insert_ok_btn,"ACTIVE",false)
        IupSetInt(insert_drop,"VALUE",0)
--      if length(add_modes)>1 then
            start_focus = insert_drop
--      end if
    end if
--  string sig = clean_sig(id)
--?{"confirm_insert","sig",sig,"id",id,"iupnames[id]",iupnames[id]}
--  bool bTitle = find(sig,{"[T]","[TH]","[TT]"})!=0
    bTitle = find("TITLE",iprops(id))!=0
--?{"bTitle",bTitle}
    IupSetInt(insert_titleh,"VISIBLE",bTitle)
    IupSetAttribute(insert_dlg, "SIZE", NULL)
    IupRefresh(insert_dlg)

    IupSetAttributeHandle(insert_dlg,"DEFAULTENTER",default_enter)
    IupSetAttributeHandle(insert_dlg,"STARTFOCUS",start_focus)

    enable_globalmotion = false

    integer {x,y} = IupGetIntInt(NULL,"CURSORPOS")
    integer {rx,ry} = sq_floor_div(IupGetIntInt(insert_dlg,"NATURALSIZE"),2)
    x = max(0,x-rx)
    y = max(0,y-ry)
    IupShowXY(insert_dlg,x,y)

end procedure

--DOC[DEV]:
-- Right-clicking on or when the main (non-empty) IupDialog is selected will show a menu with
-- all elements disabled. This is because an IupDialog can only have a single child, and further
-- an IupDialog cannot have any siblings or be a child of any other element. In fact, IupDialog 
-- is always disabled on the right-click menu, because the main IupDialog cannot be deleted.
--
-- Likewise menu items can only be placed on menus. Note however that many cases will exist
-- that offer a sibling option, but if the parent is already "full" (like IupDialog many other
-- containers can only have one child, or in the case of IupSplit two) then an error occurs
-- when OK is pressed. For that to be fixed, the unit testing would need to be rewritten, and
-- that already covers over 1,500 cases - perfectly do-able, but y'know.	[ERM, done!] (greatly simplified by removing menus...)

sequence inactive

--DEV/DOC!
-- Also note that the right-click menu Containers/IupDialog is always given a no-entry icon,
-- and will also always deliver the above message. This is because you cannot delete the
-- main IupDialog entry, and an IupDialog cannot be a child of any other element. I could
-- remove that entry, but getting the error and then understanding why is probably better.
--
-- The root node of a dialog (/window) is always, not surprisingly, an IupDialog. Perhaps
-- more surprisingly, an IupDialog can only have one child. Typically that would be an
-- IupHbox or IupVbox, which can have as many children as you like, and instruct the
-- run-time to arrange them horizontally or vertically respectively. The IupVbox and
-- IupHbox will also often be alternately-nested, eg an IupHbox with two or more
-- IupVbox in it, or an IupVbox with two or more IupHbox in it. It all gets quite
-- natural, once you get used to the idea.
--

--(disjoint ramble#17:)
-- The layout hierarchy can at first be a little off-putting, especially if you are used
-- to explicitly positioning everything at explicit x,y co-ordinates. But once you get
-- used to it, it is actually very easy (especially when you are using pGUI-IDE!) and of
-- course it makes layouts much more portable across different underlying systems, far
-- easier than {+5 on Motif, -3 on GTK, +17 on WinAPI} style, with different numbers 
-- for each of the many different gui components.

function menu_cb(Ihandle menu_item)
    integer id = IupGetInt(menu_item,"ID")
    if inactive[id] then
        enable_globalmotion = false
        error_showing = true
        IupMessage("Invalid","""
________The target element cannot have any [more] elements, so you cannot add a child,
        and its parent is full, so you cannot add a sibling, and the selected element is not
        a container, or the target is the main IupDialog, so you cannot make it a parent. 

        Right-clicking on or when the main IupDialog is selected usually displays a menu
        with all no-entry icons - try clicking on a sub-element, or add more containers, 
        most commonly IupHbox and IupVbox.
        
        This message is explained in more detail right at the start of the manual.""")
        error_showing = false
        re_enable_globalmotion()
    else
        confirm_insert(id)
    end if
    return IUP_DEFAULT
end function
constant cb_menu = Icallback("menu_cb")

function destroy_rec(integer dx)
-- (Done the long-winded manual way mainly so that we can 
--  cleanup all_handles, and count verification secondary.)
--DEV IupExpander has a hidden IupBackgroundBox... several others will too...
Ihandln ih = all_handles[dx]
integer res = IupGetChildCount(ih), kdx
    if res!=0 then
        Ihandln child = IupGetNextChild(ih, NULL)
-- fill these in as and when they get properly tested, not before:
--IupDetachBox? IupSbox, IupSpinBox, (IupSpin - [DOC] not supported anyway), IupSplit
        if find(all_funcdx[dx],{K_IupExpander}) then
            -- IupExpander has a hidden IupBackgroundBox for the bar handler,
            -- IupDetachBox, IupSbox, and IupSplit have a hidden IupCanvas "",
            -- and IupSpinBox contains an IupSpin; so discount that and start
            -- deleting from the following child.
            res -= 1
            while 1 do -- (needed for IupSplit only)
                Ihandln bruv = IupGetBrother(child)
                if bruv=NULL then exit end if
                kdx = find(bruv,all_handles)
                if kdx=0 then ?9/0 end if
                res += destroy_rec(kdx)
--              if all_funcdx[x]!=K_IupSplit then exit end if
            end while
            if IupGetChildCount(ih)!=1 then ?9/0 end if
        else
            while child!=NULL do
                kdx = find(child,all_handles)
                if kdx=0 then ?9/0 end if
                res += destroy_rec(kdx)
--              child = IupGetNextChild(NULL, child)
                child = IupGetNextChild(ih, NULL)
            end while
            if IupGetChildCount(ih)!=0 then ?9/0 end if
        end if
    end if
    if all_handles[dx]=NULL then ?9/0 end if
    ih = IupDestroy(ih)
    all_handles[dx]=NULL
--/!*
--DEV
    -- and cleanup all_tags
    kdx = find(dx,all_tags) 
    if kdx=0 then ?9/0 end if
    all_tags[kdx..kdx] = {}
--  for i=1 to length(all_tags) do
--      Ihandln hi = all_handles[all_tags[i]]
--      if hi!=NULL 
--*!/
    return res
end function

function delete_cb(Ihandle menu_item)
    integer id = IupGetInt(hierarchytree,"VALUE")
    if id=0 then
        -- (menu entry should be disabled, but no harm re-checking)
        IupMessage("Error","The main IupDialog cannot be deleted.")
    else
        string msg = "Delete "&IupGetAttributeId(hierarchytree,"TITLE",id)
        integer kids = IupGetIntId(hierarchytree,"TOTALCHILDCOUNT",id)
        if kids!=0 then
            msg &= sprintf(" and %d child%s",{kids,iff(kids=1?"":"ren")})
        end if
        if IupAlarm("Confirm",msg,"Yes","No")=1 then
            integer userdata = IupTreeGetUserId(hierarchytree, id) 
            IupSetAttributeId(hierarchytree,"DELNODE",id,"SELECTED")
            integer kidz = destroy_rec(userdata)
            if kids!=kidz then
                msg = sprintf("%d tree nodes deleted, but %d handles",{kids,kidz})
                IupMessage("Warning","Internal error? "&msg)
            end if
            IupSetAttribute(livedisplay,"SIZE",NULL)
            IupRefresh(livedisplay)
        end if
    end if
    return IUP_DEFAULT
end function
constant cb_delete = Icallback("delete_cb")


Ihandln rmenu = NULL

Ihandle timer

function timer_cb(Ihandle /*timer*/)
    IupStoreAttribute(timer, "RUN", "NO")
    if IupGetInt(timer,"TIME")!=200 then
        IupSetInt(timer,"TIME",200)
        re_enable_globalmotion()
    end if      
    if enable_globalmotion then
        if last_gm_crop!=-1 then
            -- carefully re-check everything:
            integer id = IupTreeGetUserId(hierarchytree, last_gm_crop)
            Ihandle hi = all_handles[id]
            integer {x,y} = IupGetIntInt(NULL,"CURSORPOS")
            integer {px,py} = IupGetIntInt(hi,"SCREENPOSITION")
            integer {w,h} = IupGetIntInt(hi,"RASTERSIZE")
            if x>=px and y>=py 
            and x<=px+w and y<=py+h then
                IupSetInt(hierarchytree,"VALUE",last_gm_crop)
                {} = selection_cb(hierarchytree, last_gm_crop, 1) 
            end if
        end if
    end if
    return IUP_IGNORE
end function

function globalmotion_cb(integer x, y, atom /*pStatus*/)
--DEV/SUG factor out??
--  last_gm_crop = f(x,y)
bool found = false
    for i=1 to length(all_tags) do
--      Ihandln hi = all_handles[all_tags[i]]
--      if hi!=NULL 
--      and IupGetInt(hi,"VISIBLE")!=0
        Ihandle hi = all_handles[all_tags[i]]
        if IupGetInt(hi,"VISIBLE")!=0
        and IupGetAttribute(hi,"SCREENPOSITION")!="" then
            integer {px,py} = IupGetIntInt(hi,"SCREENPOSITION")
            if x>=px and y>=py then
                integer {w,h} = IupGetIntInt(hi,"RASTERSIZE")
                if x<=px+w and y<=py+h then
                    integer id = IupTreeGetId(hierarchytree, all_tags[i]) 
                    if id!=last_gm_crop then 
                        last_gm_crop = id
                        if IupGetInt(timer,"RUN")=0 then
                            IupStoreAttribute(timer, "RUN", "YES")
                        end if
                    end if
                    found = true
                    exit
                end if
            end if
        end if
    end for
    if not found then last_gm_crop = -1 end if
    return IUP_CONTINUE 
end function
constant cb_globalmotion = Icallback("globalmotion_cb")

Ihandln attrib_menu=NULL
Ihandle attrib_menu_item

function attrib_menu_cb(Ihandle /*ih*/)
    integer item = IupGetInt(p_attrib_list,"VALUE")
    string text = IupGetAttributeId(p_attrib_list,"",item)
    integer k = match(" = ",text)
    edit_attrib(text[1..k-1],text[k+3..$])
    return IUP_CONTINUE
end function
constant cb_attrib_menu = Icallback("attrib_menu_cb")

sequence mitems = {}

Ihandle cmenu,emenu,dmenu,hmenu -- (containers, elements, delete, help)

function globalbutton_cb(integer button, pressed, x, y, atom pStatus)

    if pressed=1 then
        if p_attrib_list!=NULL then
            integer {lx,ly} = IupGetIntInt(p_attrib_list,"SCREENPOSITION")
            integer pos = IupConvertXYToPos(p_attrib_list, x-lx, y-ly) 
            if pos>=1 then
                if no_popups_active() then
                    IupSetInt(p_attrib_list,"VALUE",pos)
                end if
            elsif enable_globalmotion then

                {} = globalmotion_cb(x, y, pStatus) -- (set last_gm_crop)
--or:
--              last_gm_crop = f(x,y)
                {} = timer_cb(timer)            -- (use last_gm_crop right now)
                IupStoreAttribute(timer, "RUN", "NO")
                enable_globalmotion = false
                IupSetInt(timer,"TIME",1000)    -- delay next auto-select a bit
                IupStoreAttribute(timer, "RUN", "YES")
            end if
        end if
    elsif button=IUP_BUTTON3        -- right mouse button (released)
      and livedisplay!=NULL then

        integer {px,py} = IupGetIntInt(properties,"SCREENPOSITION")
        integer {pw,ph} = IupGetIntInt(properties,"RASTERSIZE")
        if x>=px and x<=px+pw
        and y>=py and y<=py+ph then

            -- inside properties frame:
            integer item = IupGetInt(p_attrib_list,"VALUE")
            if item!=0 
            and no_popups_active() then
                if attrib_menu=NULL then
                    attrib_menu_item = IupMenuItem("Edit %s attribute",cb_attrib_menu)
                    attrib_menu = IupMenu({attrib_menu_item})
                end if
                string text = IupGetAttributeId(p_attrib_list,"",item)
                integer k = match(" = ",text)
                text = text[1..k-1]
                IupSetStrAttribute(attrib_menu_item,"TITLE","Edit %s attribute",{text})
                attrib_active = true
                IupPopup(attrib_menu,IUP_MOUSEPOS,IUP_MOUSEPOS)
                attrib_active = false
            end if
        else
            if rmenu=NULL then
                sequence menus = {IupMenu(),IupMenu()}
                cmenu = IupSubMenu("Containers",menus[1],"IMAGE=%s",{get_image("plade_containers.png")})
                emenu = IupSubMenu("Elements",menus[2],"IMAGE=%s",{get_image("plade_elements.png")})
                dmenu = IupMenuItem("Delete",cb_delete,"IMAGE=%s",{get_image("plade_trash.png")})
                hmenu = IupMenuItem("Help",cb_help,"IMAGE=%s",{get_image("HelpPhixCHM.png")})
                rmenu = IupMenu({cmenu,emenu,dmenu,hmenu})
                mitems = repeat(NULL,length(iupnames))
                for i=1 to length(iupnames) do
                    integer cdx = find(upper(cem[i]),"CE")
                    if cdx!=0 then
                        mitems[i] = IupMenuItem(iupnames[i],cb_menu,"IMAGE=%s, ID=%d",{get_image(icons[i]),i})
                        IupAppend(menus[cdx],mitems[i])
                    end if
                end for
            end if

            integer pid = IupGetInt(hierarchytree,"VALUE")
            integer uid = IupTreeGetUserId(hierarchytree, pid)
            integer children = get_childcount(pid,uid)
            integer funcdx = all_funcdx[uid]
            Ihandln parent = IupGetParent(all_handles[uid])
            integer pkids, pdx
            if parent=NULL then
                if funcdx!=K_IupDialog then ?9/0 end if
                pdx = 0
                pkids = 0
            else
                pkids = IupGetChildCount(parent)
                pdx = find(parent,all_handles)
                pdx = all_funcdx[pdx]
            end if
            -- enable/disable menu entries appropriately
            inactive = repeat(false,length(iupnames))
            for id=1 to length(iupnames) do
                Ihandln mitem = mitems[id]
                if mitem!=NULL then
                    set_add_modes(id,pdx,pkids,funcdx,children)
                    string icon = icons[id]
                    if length(add_modes)=0 then
                        icon = "plade_no_entry.png"
                        inactive[id] = true
                    end if
                    IupSetStrAttribute(mitem,"IMAGE",get_image(icon))
                end if
            end for
            -- Prevent main IupDialog delete
            IupSetInt(dmenu,"ACTIVE",pid!=0)

            enable_globalmotion := false
            IupStoreAttribute(timer, "RUN", "NO")
            rmenu_active = true
            IupPopup(rmenu, x, y)
            rmenu_active = false
            re_enable_globalmotion()
        end if
    end if
    return IUP_CONTINUE 
end function
constant cb_globalbutton = Icallback("globalbutton_cb")

sequence depths

procedure set_depth(integer i)
    if depths[i]=0 then
        Ihandln parent = IupGetParent(all_handles[i])
        if parent=NULL then
            depths[i] = 1
        else
            integer pdx = find(parent,all_handles)
            set_depth(pdx)
            depths[i] = depths[pdx]+1
        end if
    end if
end procedure

function depth_sort(integer i, integer j)
    return compare(depths[j],depths[i]) -- (reverse order is intentional)
end function

procedure sort_tags()
    -- sort tags, depth-first (ensure that globalmotion_cb
    --  checks all the children before their parents, the
    --  exact order being otherwise of no importance):
    depths = repeat(0,length(all_tags))
    for i=1 to length(all_tags) do
        set_depth(i)
    end for 
    all_tags = custom_sort(routine_id("depth_sort"),all_tags)
end procedure

--function button_cb(integer button, pressed, x, y, atom /*pStatus*/)
--  return IUP_CONTINUE
--end function
--constant cb_button = Icallback("button_cb")

function dragdrop_cb(Ihandle /*hierarchytree*/, integer drag_id, drop_id, /*isshift*/, iscontrol) 
integer res = IUP_IGNORE
    enable_globalmotion := false
    if iscontrol then
        IupMessage("Error","Copy not supported for drag&drop.")
--  elsif drag_id=0 then -- (root/main IupDialog being dragged? - never triggers)
--      -- likewise parent onto child etc already (quietly) prohibited internally..
--      IupMessage("not supported","You cannot drag the main IupDialog anywhere!")
    else
        integer drag_dx = IupTreeGetUserId(hierarchytree, drag_id) 
        integer drop_dx = IupTreeGetUserId(hierarchytree, drop_id) 
        Ihandle drag_elem = all_handles[drag_dx]
        Ihandle drop_elem = all_handles[drop_dx]
--      Ihandln ref_child
--      integer funcdx = all_funcdx[drop_dx]
--      integer error = IUP_INVALID, noerror = IUP_CONTINUE
        integer error = IUP_INVALID
--      bool bBranch = IupGetAttributeId(hierarchytree, "KIND", drop_id)="BRANCH", bEmpty, bExpanded
        bool bBranch = IupGetAttributeId(hierarchytree, "KIND", drop_id)="BRANCH", 
             bExpanded = IupGetAttributeId(hierarchytree, "STATE", drop_id)="EXPANDED"
        if all_funcdx[drop_dx]=K_IupExpander and bExpanded then
            -- if the drop_elem is an IupExpander, then get the hidden 
            --  IupBackgroundBox and drop as next sibling of that.
            drop_elem = IupGetNextChild(drop_elem, NULL)
            bExpanded = false
        end if
--      if bBranch then
--          ref_child = IupGetNextChild(drop_elem, NULL)
--          bEmpty = IupGetIntId(hierarchytree, "CHILDCOUNT", drop_id)=0
--          bExpanded = IupGetAttributeId(hierarchytree, "STATE", drop_id)="EXPANDED"
--      end if
        if bBranch and bExpanded then
            Ihandln ref_child = IupGetNextChild(drop_elem, NULL)
            if drop_elem==IupGetParent(drag_elem) 
            and ref_child==drag_elem then
--DEV/SUG write a positional messagebox... (ie CURSORPOS/IupShowXY)
                IupMessage("Error", "Dropped at same place.")
            else
                -- If the drop node is a branch and it is expanded or
                --  empty, add as first child, before the reference
                error = IupReparent(drag_elem, drop_elem, ref_child)
            end if
--      elsif bBranch and bEmpty then
----this may no longer be necessary... (and noerror can go too)
--?"bEmpty"
--?9/0
--          -- Need to do the move ourselves and return IUP_IGNORE...
--          error = IupReparent(drag_elem, drop_elem, ref_child)
--          if error=IUP_NOERROR then
--              IupSetAttributeId(hierarchytree, "ADDLEAF", drop_id, "TEMP")
--              drag_id = IupTreeGetId(hierarchytree, drag_dx)
--              IupSetIntId(hierarchytree, "MOVENODE", drag_id, drop_id+1)
----                drop_id = IupTreeGetId(hierarchytree, drop_dx)
--              integer temp = IupTreeGetId(hierarchytree, 0)
--              IupSetAttributeId(hierarchytree, "DELNODE", temp, "SELECTED")
----IupUnmap(drop_elem)
----IupMap(drop_elem)
----IupUnmap(drag_elem)
----IupMap(drag_elem)
----
----DOH! This is /exactly/ the problem I was trying to avoid...
----                IupSetIntId(hierarchytree,"MOVENODE",drag_id,drop_id)
----                drop_id = IupTreeGetId(hierarchytree, drop_dx)
----No help...
----                IupSetAttributeId(hierarchytree,"STATE",drop_id,"EXPANDED")
----                IupRefresh(hierarchytree)
----                IupUpdate(hierarchytree)
--          end if
--          noerror = IUP_IGNORE
--
        else
            Ihandln drop_parent = IupGetParent(drop_elem),
                    drag_parent = IupGetParent(drag_elem),
                    drop_brother = IupGetBrother(drop_elem)
            if drop_parent=NULL then
                IupMessage("Error", "Cannot drop here as brother.")
            elsif drop_parent==drag_parent 
              and drop_brother==drag_elem then
                IupMessage("Error", "Dropped at same place.")
            else
                -- If the branch is not expanded or the drop node is a leaf,
                --  add as brother, after the reference (can be NULL here)
                error = IupReparent(drag_elem, drop_parent, drop_brother)   
            end if
        end if

        if error==IUP_ERROR then

            IupMessage("Error", "Drop failed. Invalid operation for this node.")

        elsif error=IUP_NOERROR then

            -- This seems to do the trick:
            IupUnmap(drop_elem)
            IupMap(drop_elem)
            IupUnmap(drag_elem)
            IupMap(drag_elem)

            IupRefresh(livedisplay)

--          res = noerror
            res = IUP_CONTINUE
        end if

    end if -- (iscontrol)

    sort_tags()

    re_enable_globalmotion()
    return res
end function
constant cb_dragdrop = Icallback("dragdrop_cb")

procedure sample_selected(bool from_sample)
    --DEV later...?
    --?"line 4501" {} = wait_key()
--?5917
    init_constants()
    sequence s = split_path(initialcurrentdir)
    integer k = find("demo",s)
    if k=0 then ?9/0 end if
    s = s[1..k-1]&split_path(src)
    src = join_path(s)
--?src

    srcname = get_file_name(src)

    integer fn = open(src,"r")
    if fn=-1 then
        IupMessage("Error","Error reading "&src)
        src = ""
        return
    end if
    text = get_text(fn,GT_LF_STRIPPED)
    close(fn)

--  IupSetStrAttribute(main_dlg, "TITLE", "plade - Phix Layout Designer (%s)",{srcname})

    parse_source()

    anaylse()

    all_handles = {}
    all_tags = {}
    all_funcdx = {}
    all_properties = {}

    handles = repeat(0,length(parse_data))
    RASTERSIZENULL = {}
--?{"livedisplay",livedisplay}
    if livedisplay!=NULL then
--?"kill"
        IupHide(livedisplay)
        livedisplay = IupDestroy(livedisplay)
--      livedisplay = NULL
    end if
    last_gm_crop = -1
    --/*END*/

--DEV
    if from_sample and length(dialogs)=1 then
        make_live(1)
    else
        window_selection(from_sample)
    end if

end procedure


Ihandle sample_list, samp_info

constant samp_desc1 = "Simple use of IupFill()"

constant {samp_names,samp_descs} = columnize({
--      {`demo\pGUI\fill.exw`,"Simple use of IupFill()"},
        {`demo\pGUI\fill.exw`,samp_desc1},
        {`demo\pGUI\hbox.exw`,"Simple use of IupHbox()"},
        {`demo\pGUI\GraphR.exw`,"IupCanvas() - not much for pGUI-IDE to do here"},
        {`demo\pGUI\calendar.exw`,"Simple use of IupCalandar()"},
        {`demo\pGUI\detachbox.exw`,"Simple IupDetachBox() example"},
        {`demo\pGUI\list2.exw`,"IupList() - two dropdown and two not"},
        {`demo\pGUI\matrix3.exw`,"IupMatrix() - NB dynamic ones are usually blank!"},
        {`demo\pGUI\radio.exw`,"Simple IupRadio() example"},
        {`demo\pGUI\rot13.exw`,"Simple rot13 application"},
        {`demo\pGUI\sample.exw`,"The standard controls example"},
        {`demo\pGUI\simple_notepad.exw`,"Simple notepad application (3 windows)"},
        {`demo\pGUI\simple_paint.exw`,"Simple paint application (3 windows)"},
        {`demo\pGUI\tabs.exw`,"IupTabs() - NB dynamic ones are usually blank!"},
        {`demo\pGUI\toggle.exw`,"IupToggle() - note images are not shown"},
        -- aside: "&" added so that plade.exw does not appear when filtering for these in pdemo
        {`demo\rosetta\7`&`guis\Counter.exw`,"Simple counter example"},
        {`demo\rosetta\7`&`guis\Booker.exw`,"Flight booking example"},
        {`demo\rosetta\7`&`guis\Cells.exw`,"Simple spreadsheet"},
        {`demo\rosetta\7`&`guis\CircleDraw.exw`,"Simple drawing example"},
        {`demo\rosetta\7`&`guis\Converter.exw`,"Temperature conversion example"},
        {`demo\rosetta\7`&`guis\CRUD.exw`,"Create, Read, Update, Delete example"},
        {`demo\rosetta\7`&`guis\Timer.exw`,"Simple timer example"}})

--forward procedure sample_selection()

function samp_ok_cb(Ihandln /*samp_ok_btn*/)
    integer k = IupGetInt(sample_list,"VALUE")
    src = samp_names[k]
--  if samp_dlg!=NULL then
--      IupHide(samp_dlg)
--else
----DEV...
--  ?"***samp_dlg=NULL!!***!"
--  end if
--  sample_selection(true)
    sample_selected(true)
    return IUP_DEFAULT
--  return IUP_CLOSE
end function

function samp_cancel_cb(Ihandle /*samp_cancel_btn*/)
--  src = ""
    IupHide(samp_dlg)
    return IUP_DEFAULT
--  return IUP_CLOSE
end function

function sample_changed_cb(Ihandle /*L*/)
integer k = IupGetInt(sample_list,"VALUE")
    IupSetAttribute(samp_info,"TITLE",samp_descs[k])
    src = samp_names[k]
    return IUP_CONTINUE
end function
constant cb_sample_changed = Icallback("sample_changed_cb")

function sample_dblclick_cb(Ihandle /*sample_list*/, integer /*item*/, atom /*pText*/)
    return samp_ok_cb(sample_list)
end function
constant cb_sample_dblclick = Icallback("sample_dblclick_cb")

--procedure sample_selection(bool from_sample)
procedure sample_selection()
Ihandle samp_buttons, samp_ok_btn, samp_cancel_btn
string title
--?"sample_selection"

    if src="" then
        if samp_dlg=NULL then
            sample_list = IupList("VALUECHANGED_CB",cb_sample_changed,"DROPDOWN=NO, EXPAND=HORIZONTAL")
            IupSetCallback(sample_list,"DBLCLICK_CB",cb_sample_dblclick)

            for sx=1 to length(samp_names) do
                title = samp_names[sx]
                IupSetStrAttributeId(sample_list,"",sx,title)
            end for
            IupSetInt(sample_list,"VALUE",1)

--          samp_info = IupLabel(samp_descs[1],"EXPAND=HORIZONTAL")
            samp_info = IupLabel(samp_desc1,"EXPAND=HORIZONTAL")
            samp_ok_btn = IupButton("OK", Icallback("samp_ok_cb"), "PADDING=5x5")
            samp_cancel_btn = IupButton("Cancel", Icallback("samp_cancel_cb"), "PADDING=5x5")

            samp_buttons = IupHbox({IupFill(),samp_ok_btn,IupFill(),samp_cancel_btn,IupFill()})

            samp_dlg = IupDialog(IupVbox({sample_list,
                                          IupFill(),
                                          samp_info,
                                          IupFill(),
                                          samp_buttons},
                                         "MARGIN=5x5"),
                                 "MINSIZE=300x140")
            IupSetAttribute(samp_dlg,"TITLE","Sample Selection")
            IupSetAttributeHandle(samp_dlg,"DEFAULTENTER",samp_ok_btn)
            IupSetAttributeHandle(samp_dlg,"DEFAULTESC",samp_cancel_btn)
            IupSetAttributeHandle(samp_dlg,"STARTFOCUS",sample_list)

--          IupSetCallback(wsdlg, "K_ANY", Icallback("esc_close"))
--DEV maybe not...
--          IupCloseOnEscape(samp_dlg)
            IupSetAttributeHandle(samp_dlg,"PARENTDIALOG",main_dlg)
        end if

        IupShow(samp_dlg)

--?{"ssld",livedisplay}
--      if livedisplay=NULL then
--          IupMainLoop()
--      else
--          livedisplay = NULL
--      end if
--?src

--      if src="" then return end if

--      samp_dlg = IupDestroy(samp_dlg)
--      sample_list = NULL
    else
--      ??()
--      samp_ok_cb(NULL)
        sample_selected(false)
    end if

end procedure

function new_attr_cb(Ihandle /*p_new*/)
    edit_attrib("","")
    return IUP_DEFAULT
end function
constant cb_new_attr = Icallback("new_attr_cb")

function samp_menu_cb(Ihandle /*ih*/)
    src = ""
    sample_selection()
    return IUP_DEFAULT
end function
constant cb_samp_menu = Icallback("samp_menu_cb")

function dump_pd_cb(Ihandle /*ih*/)
string filename = initialcurrentdir&"parse_data.txt"
integer fn = open(filename,"w")
    pp(parse_data,{pp_File,fn,pp_StrFmt,-2})
    pp(text,{pp_File,fn,pp_StrFmt,-2,pp_Nest,1})
    close(fn)
    IupMessage("Done",filename&" written")
    return IUP_DEFAULT
end function
constant cb_dump_pd = Icallback("dump_pd_cb")

function dump_log_cb(Ihandle /*ih*/)
string filename = initialcurrentdir&"pGUI-IDE.log"
integer fn = open(filename,"w")
    puts(fn,"DEV!\n")
--  puts(1,"insertion_points:\n")
--?insertion_points
    close(fn)
    IupMessage("Done",filename&" written")
    return IUP_DEFAULT
end function
constant cb_dump_log = Icallback("dump_log_cb")

function dump_updates_cb(Ihandle /*ih*/)
string filename = initialcurrentdir&"updates.lst"
integer fn = open(filename,"w")
    puts(fn,"DEV!\n")
    close(fn)
    IupMessage("Done",filename&" written")
    return IUP_DEFAULT
end function
constant cb_dump_updates = Icallback("dump_updates_cb")

--function crash_cb(Ihandle /*ih*/)
--  return 9/0
--end function
--constant cb_crash = Icallback("crash_cb")

procedure main()
Ihandle file_menu, dev_menu, test_menu, help_menu, main_menu, vboxp

    IupOpen()

    timer = IupTimer(Icallback("timer_cb"), 200, 1)

--SUG: Examples -> submenu with readme (ie readonly), sample.exw, ... (see list above)
--                  note this will require some (much-needed) reorganisation.
--                  If Edix is asked to run pGUI-IDE on a different file, it should
--                  prompt: save/discard/use tabbed dialog, ditto samples.
--SUG: warnings (6) - disabled with "(0)" or "" if none, creates warnings.txt file?
    dev_menu = IupMenu({IupMenuItem("&Samples",cb_samp_menu),
                        IupMenuItem("Show expected hierarchy"), -- DEV grey out if not available
                        IupMenuItem("Write &parse_data.txt",cb_dump_pd),
                        IupMenuItem("Write pGUI-IDE.&log",cb_dump_log),
                        IupMenuItem("Write &updates.lst",cb_dump_updates)})
--                      IupMenuItem("Write &updates.lst",cb_dump_updates),
--                      IupMenuItem("Crash",cb_crash)})
    file_menu = IupMenu({IupMenuItem("&Cancel"),
--                       IupMenuItem("&Save"),
                         IupSeparator(),
                         IupSubMenu("&Developer",dev_menu),
                         IupSeparator(),
--                       IupMenuItem("&Undo", "ACTIVE=NO"),
                         IupMenuItem("Save and E&xit", cb_exit)})
-- possibly via edix, disable if not running?
    test_menu = IupMenuItem("&Test", Icallback("test_cb"))
    help_menu = IupMenuItem("&Help", cb_help)
    
    main_menu = IupMenu({IupSubmenu("&File", file_menu),test_menu,help_menu})

--Ihandle tabframe
--if SHOWTABS then
--  Ihandle vboxc = IupVbox({})
--  Ihandle radioc = IupRadio(vboxc)
--  Ihandle vboxe = IupVbox({})
--  Ihandle radioe = IupRadio(vboxe)
--  Ihandle vboxm = IupVbox({})
--  Ihandle radiom = IupRadio(vboxm)
--  sequence vboxes = {vboxc,vboxe,vboxm}
--  Ihandle tabs = IupTabs({radioc,radioe,radiom})
--  IupSetAttribute(tabs,"TABTITLE0","Containers")
--  IupSetAttribute(tabs,"TABTITLE1","Elements")
--  IupSetAttribute(tabs,"TABTITLE2","Menus")
--  IupSetAttribute(tabs,"SIZE","120x")
--
----DEV containers/elements/warnings tabs?
--  for i=1 to length(iupnames) do
--      string iupname = iupnames[i]
--      string icon = icons[i]
--      Ihandle lbl = IupLabel("NULL")
--      IupSetStrAttribute(lbl, "IMAGE", get_image(icon))
--      Ihandle tgl = IupToggle(iupname)
--      IupAppend(vboxes[find(upper(cem[i]),"CEM")],IupHbox({lbl,tgl},"NORMALSIZE=HORIZONTAL"))
--      if iupname="IupDialog" then
--          IupSetAttributeHandle(radioc,"VALUE",tgl)
--      end if
--  end for
--
--  tabframe = IupFrame(tabs,`TITLE="Controls", PADDING=5x`)
--end if

--  Ihandle tree = IupTree()--"")
--  Ihandle tree = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=205x416, EXPAND=HORIZONTAL")
--  hierarchytree = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=225x416, EXPAND=HORIZONTAL")
    hierarchytree = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=325x416, EXPAND=YES")
--DEV so.. my controls should be a tree!! (with a delete branch)
    IupSetAttribute(hierarchytree, "SHOWDRAGDROP", "YES");
    IupSetCallback(hierarchytree,"SELECTION_CB",cb_selection)
    IupSetCallback(hierarchytree,"RIGHTCLICK_CB",cb_rightclick)
    IupSetCallback(hierarchytree,"DRAGDROP_CB",cb_dragdrop)

--  Ihandle tree = IupTree("DRAGDROPTREE=YES, RASTERSIZE=205x416, EXPAND=HORIZONTAL")
--  Ihandle tframe = IupFrame(IupVbox({IupVbox({tree,IupLabel()}),IupLabel()}),
    Ihandle treeframe, right
--if SHOWDESIRED then
--  hierarchytreE = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=225x416, EXPAND=HORIZONTAL")
--  right = IupHbox({hierarchytree,hierarchytreE})
----    treeframe = IupFrame(IupVbox({IupHbox({hierarchytree,hierarchytreE}),IupLabel("")}),
------                    "TITLE=Hierarchy, PADDING=5x, RASTERSIZE=150x275, EXPAND=NO")
----                      "TITLE=Hierarchy, PADDING=5x")
----DEV
--elsif SHOWDETAILS then
if SHOWDETAILS then
    p_new = IupButton("New",cb_new_attr)
    p_space_only = IupToggle("spacing only",cb_space,"VALUE=OFF, RIGHTBUTTON=YES, 3STATE=YES")
    if not SPACE then
        IupSetInt(p_space_only,"ACTIVE",0)
    end if
    p_desc = IupLabel("(desc)","EXPAND=HORIZONTAL")
    p_attrib_list = IupList(cb_list_action,"EDITBOX=NO, EXPAND=YES")
    IupSetCallback(p_attrib_list,"DBLCLICK_CB",cb_dblclick)
    vboxp = IupVbox({IupHbox({p_new,IupFill(),p_space_only}),p_desc,p_attrib_list})
    properties = IupFrame(vboxp,`TITLE="Properties ", RASTERSIZE=225x416, EXPAND=YES`)
    right = IupSplit(hierarchytree,properties)
else
    right = hierarchytree
end if
    treeframe = IupFrame(right,`TITLE="Hierarchy ", PADDING=5x`)

--  dlg = IupDialog(frame,"MENU=mymenu, TITLE=plade, SOIZE=200x100, GOAP=5x5")
--  dlg = IupDialog(IupHbox({frame,IupFill(),treeframe,IupFill()},"MARGIN=5x"),
--if SHOWTABS then
-- if SHOWDESIRED or SHOWDETAILS then
--  dlg = IupDialog(IupHbox({tabframe,treeframe},"MARGIN=5x"),"SIZE=553x275") 
-- else
--  dlg = IupDialog(IupHbox({tabframe,treeframe},"MARGIN=5x"),"SIZE=328x275") 
-- end if
--else
-- if SHOWDESIRED or SHOWDETAILS then
--  dlg = IupDialog(treeframe,"SIZE=553x275") 
-- else
--  dlg = IupDialog(treeframe,"SIZE=328x275") 
-- end if
    main_dlg = IupDialog(treeframe)
--end if
    IupSetAttributeHandle(main_dlg,"MENU",main_menu)
--DEV on change of src:
    IupSetCallback(main_dlg, "K_ANY", Icallback("key_cb"));
--  IupCloseOnEscape(dlg)
--DEV/SUG:
--  IupCloseOnEsc(dlg)
    IupSetCallback(main_dlg, "CLOSE_CB", cb_close)
--  IupSetCallback(matrix, "RELEASE_CB",    demo:cb_release)
--INPUTCALLBACKS    Turns on/off ("YES" or "NO") the global callbacks used to intercept global mouse and keyboard events. 
--The callbacks must be set using the IupSetGlobalFunction function using the following names: GLOBALKEYPRESS_CB, GLOBALMOTION_CB, GLOBALBUTTON_CB and GLOBALWHEEL_CB (Windows Only). 
--Their parameters are the same as the standard callbacks, but without the Ihandle parameter. 
--(ie/see KEYPRESS_CB, MOTION_CB, BUTTON_CB, and WHEEL_CB)  
    IupSetGlobal("INPUTCALLBACKS","YES")
--  IupSetGlobalFunction("GLOBALBUTTON_CB",cb_button)
--works, but...
--if 01 then
    IupSetGlobalFunction("GLOBALMOTION_CB",cb_globalmotion)
    IupSetGlobalFunction("GLOBALBUTTON_CB",cb_globalbutton)
--end if
    IupMap(main_dlg)
--  IupShowXY(main_dlg,IUP_LEFT,IUP_TOP)

--if SHOWDESIRED then
--  --DEV move to Developer/Show expected hierarchy..
--  {} = setup_tree()   -- in hierarchytreE / temp
--end if

    sample_selection()
--  if src="" then return end if
--  IupSetStrAttribute(dlg, "TITLE", "plade - Phix Layout Designer (%s)",{srcname})

--if 01 then
--  window_selection()
--else
----    make_live(1)
--  make_live(0)
--end if

--  IupShow(dlg)
--  free_console()
--sleep(1)
--  if livedisplay!=NULL then
--      IupShowXY(main_dlg,IUP_LEFT,IUP_TOP)
--      -- start with the dialog selected:
--      {} = selection_cb(hierarchytree, 0, 1) 
        IupMainLoop()
--  end if
    IupClose()
end procedure
--if 01 then
main()
--end if

--/*
SUG: as we click on tree items, IupSetFocus the matching Controls toggle?
SUG: "warnings" button, with the red flag of filedump, disabled if none. (opens a popup)
SUG? Please delete xxx line nnn manually (you can/should leave this open while you do)
     and/or: error line nnn: each element should be declared on a single line
    (eg IupHbox({
                 IupFill(),
                 IupButton(OK),
                 IupFill()
                })
    not
       IupHbox({IupFill(),IupButton(OK),IupFill()})
    Note the same applies for any trailing brackets/braces.
    [plade could delete the whole IupHbox, but not ...])
    NO:<< just do it!. (what about static Ihandles that are no longer used?)

Obvious:
    Make the changes locally, ensure it will still scan. Prior to both Save and Test.
    Have a Test button which writes to plade_test.exw (warn before overwrite?), run, then delete.
    If it won't scan, write to plade_test.exw, leave, and prompt to that effect.

We need to process the thing into a flat list, and verify flags/idx are all ok.
plade is not able to handle say:
    Ihandle box
    if show_vertical then   -- (some application-defined setting/flag)
        box = IupVbox({ctrl1,ctrl2})
    else
        box = IupHbox({ctrl1,ctrl2})
    end if
plade will get confused, unless:
    a) "box" is defined/created in one and only one place, and 
    b) "ctrl1" and "ctrl2" are used once and only once in the tree,
    c) obviously if "ctrl2" is not defined/found, we must give up.
plade should, however, cope with multiple IupDialog -> select. [DONE]
--*/

